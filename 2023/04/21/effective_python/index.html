<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Effective Python》总结 | Chao Pang的个人主页</title><meta name="author" content="Chao Pang"><meta name="copyright" content="Chao Pang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章  培养Pythonic思维第1条  查询自己使用的Python版本1$ python3 --version  不要使用Python2！ 推荐3.8左右的版本（写于2023-04），初学者不要用太新的版本，很多库不支持最新版。 第2条  遵循PEP8风格指南PEP8全称Python Enhancement Proposal #8，是针对Python代码格式编订的风格指南。不符合PEP8的做法">
<meta property="og:type" content="article">
<meta property="og:title" content="《Effective Python》总结">
<meta property="og:url" content="http://sdupc.top/2023/04/21/effective_python/index.html">
<meta property="og:site_name" content="Chao Pang的个人主页">
<meta property="og:description" content="第一章  培养Pythonic思维第1条  查询自己使用的Python版本1$ python3 --version  不要使用Python2！ 推荐3.8左右的版本（写于2023-04），初学者不要用太新的版本，很多库不支持最新版。 第2条  遵循PEP8风格指南PEP8全称Python Enhancement Proposal #8，是针对Python代码格式编订的风格指南。不符合PEP8的做法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/09/17/8fUOFNuDGX1lnhJ.jpg">
<meta property="article:published_time" content="2023-04-21T11:25:39.000Z">
<meta property="article:modified_time" content="2024-07-06T07:03:35.521Z">
<meta property="article:author" content="Chao Pang">
<meta property="article:tag" content="书籍总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/09/17/8fUOFNuDGX1lnhJ.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://sdupc.top/2023/04/21/effective_python/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Effective Python》总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-06 15:03:35'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/11/29/nu4tpl8PIgFQBAr.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/09/17/8fUOFNuDGX1lnhJ.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Chao Pang的个人主页"><span class="site-name">Chao Pang的个人主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Effective Python》总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-21T11:25:39.000Z" title="发表于 2023-04-21 19:25:39">2023-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-06T07:03:35.521Z" title="更新于 2024-07-06 15:03:35">2024-07-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Effective Python》总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-培养Pythonic思维"><a href="#第一章-培养Pythonic思维" class="headerlink" title="第一章  培养Pythonic思维"></a>第一章  培养Pythonic思维</h1><h2 id="第1条-查询自己使用的Python版本"><a href="#第1条-查询自己使用的Python版本" class="headerlink" title="第1条  查询自己使用的Python版本"></a>第1条  查询自己使用的Python版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 --version</span><br></pre></td></tr></table></figure>

<p>不要使用Python2！</p>
<p>推荐3.8左右的版本（写于2023-04），初学者不要用太新的版本，很多库不支持最新版。</p>
<h2 id="第2条-遵循PEP8风格指南"><a href="#第2条-遵循PEP8风格指南" class="headerlink" title="第2条  遵循PEP8风格指南"></a>第2条  遵循PEP8风格指南</h2><p>PEP8全称Python Enhancement Proposal #8，是针对Python代码格式编订的风格指南。不符合PEP8的做法一般编译器（如Pycharm）会自动检查标黄提醒。以下是一些重点规范：</p>
<ul>
<li>用4个空格表示缩进，而不是制表符</li>
<li>下划线变量命名。</li>
<li>表达式一行写不下，可以用括号括起来，不要用 \ 续行。</li>
<li>import语句放在开头，总是使用绝对名称，按顺序划为三部分：标准库、第三方、自己的模块。</li>
</ul>
<h2 id="第3条-了解bytes与str区别"><a href="#第3条-了解bytes与str区别" class="headerlink" title="第3条  了解bytes与str区别"></a>第3条  了解bytes与str区别</h2><p>bytes包含的是原始数据，即8位无符号值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">b&#x27;h\x65llo&#x27;</span></span><br></pre></td></tr></table></figure>

<p>str包含的是Unicode码点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;a\u0300 propos&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第4条-用支持插值的f-string取代C风格的格式字符串与str-format方法"><a href="#第4条-用支持插值的f-string取代C风格的格式字符串与str-format方法" class="headerlink" title="第4条  用支持插值的f-string取代C风格的格式字符串与str.format方法"></a>第4条  用支持插值的f-string取代C风格的格式字符串与str.format方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;jerry&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s and %s&#x27;</span> % (a, b))    <span class="comment"># C风格的格式字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; and &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(a, b))    <span class="comment"># str.format方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> and <span class="subst">&#123;b&#125;</span>&#x27;</span>)    <span class="comment"># 支持插值的f-string</span></span><br></pre></td></tr></table></figure>

<h2 id="第5条-用辅助函数取代复杂的表达式"><a href="#第5条-用辅助函数取代复杂的表达式" class="headerlink" title="第5条  用辅助函数取代复杂的表达式"></a>第5条  用辅助函数取代复杂的表达式</h2><p>即使这个函数只用两三次，也是值得的。</p>
<h2 id="第6条-把数据结构直接拆分到多个变量里，不要专门通过下标访问"><a href="#第6条-把数据结构直接拆分到多个变量里，不要专门通过下标访问" class="headerlink" title="第6条  把数据结构直接拆分到多个变量里，不要专门通过下标访问"></a>第6条  把数据结构直接拆分到多个变量里，不要专门通过下标访问</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">first, second = items</span><br></pre></td></tr></table></figure>

<h2 id="第7条-尽量用enumerate取代range"><a href="#第7条-尽量用enumerate取代range" class="headerlink" title="第7条  尽量用enumerate取代range"></a>第7条  尽量用enumerate取代range</h2><p>enumerate与zip都生成lazy generator。enumerate可以同时迭代出下标与数据。</p>
<h2 id="第8条-用zip函数同时遍历两个生成器"><a href="#第8条-用zip函数同时遍历两个生成器" class="headerlink" title="第8条  用zip函数同时遍历两个生成器"></a>第8条  用zip函数同时遍历两个生成器</h2><p>注意：如果提供的迭代器长度不一致，只要其中一个迭代器迭代完毕，zip就会停止。</p>
<p>如果想按最长的那个迭代器遍历，应该改用itertools.zip_longest函数。</p>
<h2 id="第9条-不要在for与while循环后面写else块"><a href="#第9条-不要在for与while循环后面写else块" class="headerlink" title="第9条  不要在for与while循环后面写else块"></a>第9条  不要在for与while循环后面写else块</h2><p>for与while后的else（如果循环没有从头到尾执行完，就不会执行else块里的内容）与其他else逻辑（如果没执行前面的语句，那就执行else块）不同。容易造成混淆。</p>
<h2 id="第10条-用赋值表达式减少重复代码"><a href="#第10条-用赋值表达式减少重复代码" class="headerlink" title="第10条  用赋值表达式减少重复代码"></a>第10条  用赋值表达式减少重复代码</h2><p>海象运算符（:&#x3D;），3.8版本引入的语法。</p>
<h1 id="第二章-列表与字典"><a href="#第二章-列表与字典" class="headerlink" title="第二章  列表与字典"></a>第二章  列表与字典</h1><h2 id="第11条-学会对序列做切片"><a href="#第11条-学会对序列做切片" class="headerlink" title="第11条  学会对序列做切片"></a>第11条  学会对序列做切片</h2><p>类似a[1:5:2]，1为起始下标（包含），5为结束下标（不包含），2为步进。</p>
<h2 id="第12条-不要在切片里同时指定起止下标和步进"><a href="#第12条-不要在切片里同时指定起止下标和步进" class="headerlink" title="第12条  不要在切片里同时指定起止下标和步进"></a>第12条  不要在切片里同时指定起止下标和步进</h2><p>如果必须同时用这三个，那就分成两次做。而且应该把最能缩减列表长度的操作放在前面。</p>
<h2 id="第13条-通过带星号的unpacking操作来捕获多个元素，不要用切片"><a href="#第13条-通过带星号的unpacking操作来捕获多个元素，不要用切片" class="headerlink" title="第13条  通过带星号的unpacking操作来捕获多个元素，不要用切片"></a>第13条  通过带星号的unpacking操作来捕获多个元素，不要用切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">car_ages = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">oldest, *others, youngest = car_ages</span><br></pre></td></tr></table></figure>

<p>这种带*的表达式可以出现在任意位置，但必须得有个值与其匹配，并且同一级中只能有一个。</p>
<h2 id="第14条-用sort方法的key参数来表示复杂的排序逻辑"><a href="#第14条-用sort方法的key参数来表示复杂的排序逻辑" class="headerlink" title="第14条  用sort方法的key参数来表示复杂的排序逻辑"></a>第14条  用sort方法的key参数来表示复杂的排序逻辑</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tools.sort(key=<span class="keyword">lambda</span> x: x.weight)</span><br></pre></td></tr></table></figure>

<p>sort函数有reverse参数，可以将默认的升序变成降序。</p>
<p>但reverse会同时改变所有指标的排序方式，对支持一元减操作符的类型可以取反，不支持的话可以多次排序。sort是稳定的排序算法。</p>
<h2 id="第15条-不要过分依赖给字典添加条目时所用的顺序"><a href="#第15条-不要过分依赖给字典添加条目时所用的顺序" class="headerlink" title="第15条  不要过分依赖给字典添加条目时所用的顺序"></a>第15条  不要过分依赖给字典添加条目时所用的顺序</h2><p>在Python3.5以及以前的版本中，字典不保证迭代顺序与插入顺序一致。但3.6版本以后会保留键值对添加时所用的顺序。</p>
<h2 id="第16条-用get处理键不在字典中的情况，不要使用in与KeyError"><a href="#第16条-用get处理键不在字典中的情况，不要使用in与KeyError" class="headerlink" title="第16条  用get处理键不在字典中的情况，不要使用in与KeyError"></a>第16条  用get处理键不在字典中的情况，不要使用in与KeyError</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = counters.get(key, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>get函数第一个参数指定想查的键，第二个参数指定这个键不在时返回的值。</p>
<h2 id="第17条-用defaultdict处理内部状态中缺失的元素，而不要用setdefault"><a href="#第17条-用defaultdict处理内部状态中缺失的元素，而不要用setdefault" class="headerlink" title="第17条  用defaultdict处理内部状态中缺失的元素，而不要用setdefault"></a>第17条  用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visits</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, country, city</span>):</span></span><br><span class="line">        self.data[country].add(city)</span><br></pre></td></tr></table></figure>

<h2 id="第18条-学会利用-missing-构造依赖键的默认值"><a href="#第18条-学会利用-missing-构造依赖键的默认值" class="headerlink" title="第18条  学会利用__missing__构造依赖键的默认值"></a>第18条  学会利用__missing__构造依赖键的默认值</h2><p>传给defaultdict的函数必须是不需要参数的函数，无法创造出需要依赖键名的默认值。</p>
<p>可以定义一个自己的dict子类并实现__missing__方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pictures</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        value = open_picture(key)</span><br><span class="line">        self[key] = value</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<h1 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章  函数"></a>第三章  函数</h1><h2 id="第19条-不要把函数返回的多个数值拆分到三个以上的变量中"><a href="#第19条-不要把函数返回的多个数值拆分到三个以上的变量中" class="headerlink" title="第19条  不要把函数返回的多个数值拆分到三个以上的变量中"></a>第19条  不要把函数返回的多个数值拆分到三个以上的变量中</h2><p>函数返回的其实是个元组。</p>
<p>返回值应该通过小类或namedtuple实例完成。</p>
<h2 id="第20条-遇到意外状况时应该抛出异常，不要返回None"><a href="#第20条-遇到意外状况时应该抛出异常，不要返回None" class="headerlink" title="第20条  遇到意外状况时应该抛出异常，不要返回None"></a>第20条  遇到意外状况时应该抛出异常，不要返回None</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">careful_divide</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    		<span class="keyword">return</span> a / b</span><br><span class="line">  	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">result = careful_divide(x, y)</span><br><span class="line"><span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Invalid inputs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 但是，调用者可能会这么用。那么，当x为0时，结果为0，也会被判定为无效输入</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Invalid inputs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以改为下面这样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">careful_divide</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    		<span class="keyword">return</span> a / b</span><br><span class="line">  	<span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    		<span class="keyword">raise</span> ValueError(<span class="string">&#x27;Invalid inputs&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第21条-了解如何在闭包里面使用外围作用域中的变量"><a href="#第21条-了解如何在闭包里面使用外围作用域中的变量" class="headerlink" title="第21条  了解如何在闭包里面使用外围作用域中的变量"></a>第21条  了解如何在闭包里面使用外围作用域中的变量</h2><p>引用变量时，会按照以下顺序在各个作用域里查找这个变量：</p>
<ul>
<li>当前函数的作用域</li>
<li>外围作用域</li>
<li>包含当前代码的那个模块所对应的作用域（全局作用域）</li>
<li>内置作用域</li>
</ul>
<p>但在变量赋值时，如果当前作用域不存在这个变量，那么即使外围作用域里有同名的变量，Python也还是会把这次的赋值当做变量的定义处理。这样可以防止函数中的局部变量污染外围模块。</p>
<p>先用nonlocal声明再赋值就可以修改外围作用域中的变量。</p>
<h2 id="第22条-用数量可变的位置参数给函数设计清晰的参数列表"><a href="#第22条-用数量可变的位置参数给函数设计清晰的参数列表" class="headerlink" title="第22条  用数量可变的位置参数给函数设计清晰的参数列表"></a>第22条  用数量可变的位置参数给函数设计清晰的参数列表</h2><p>这些位置参数通常简称varargs或star args。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span>(<span class="params">message, *values</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> values:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values_str = <span class="string">&#x27;, &#x27;</span>.join(<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;message&#125;</span>: <span class="subst">&#123;values_str&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意： * 操作符在生成器前，程序可能因为内存耗尽崩溃。</p>
<h2 id="第23条-用关键字参数来表示可选的行为"><a href="#第23条-用关键字参数来表示可选的行为" class="headerlink" title="第23条  用关键字参数来表示可选的行为"></a>第23条  用关键字参数来表示可选的行为</h2><p>传参除了按位置，还可以按关键字传递。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span>(<span class="params">number, divisor</span>):</span></span><br><span class="line">    <span class="keyword">return</span> number % divisor</span><br><span class="line"></span><br><span class="line">remainder(<span class="number">20</span>, <span class="number">7</span>)</span><br><span class="line">remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</span><br><span class="line">remainder(divisor=<span class="number">7</span>, number=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>以上四种写法效果相同。</p>
<p>把 ** 运算符加在字典前面，会把字典里面的键值对以关键字参数的形式传给函数。</p>
<p>关键字参数有三个好处：</p>
<ul>
<li>让初次阅读的人更容易看懂</li>
<li>可以带有默认值</li>
<li>可以很灵活地扩展函数，不用担心会影响原有的函数调用代码，有助于维护向后兼容</li>
</ul>
<h2 id="第24条-用None和docstring来描述默认值会变的参数"><a href="#第24条-用None和docstring来描述默认值会变的参数" class="headerlink" title="第24条  用None和docstring来描述默认值会变的参数"></a>第24条  用None和docstring来描述默认值会变的参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">data, default=&#123;&#125;</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> default</span><br></pre></td></tr></table></figure>

<p>上面的写法系统只会计算一次default参数（在加载这个模块的时候），所以每次调用的时候，给调用者返回的都是同一个 {} ，程序会出现很奇怪的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo = decode(<span class="string">&#x27;bad data&#x27;</span>)</span><br><span class="line">foo[<span class="string">&#x27;stuff&#x27;</span>] = <span class="number">5</span></span><br><span class="line">bar = decode(<span class="string">&#x27;also bad&#x27;</span>)</span><br><span class="line">bar[<span class="string">&#x27;meep&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Foo: &#x27;</span>, foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bar: &#x27;</span>, bar)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Foo: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">Bar: &#123;<span class="string">&#x27;stuff&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;meep&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>解决这个问题，可以把默认值设成None，并在docstring中说明。</p>
<h2 id="第25条-用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"><a href="#第25条-用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表" class="headerlink" title="第25条  用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表"></a>第25条  用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span>(<span class="params">numerator, denominator, /,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ndigits=<span class="number">10</span>, *,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ignore_overflow=<span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ignore_zero_division=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Keyword-only argument是一种只能通过关键字指定而不能通过位置指定的参数。这迫使调用者必须指明这个值是传递给哪一个参数的。这些参数位于 * 符号的右侧。</li>
<li>Positional-only argument是一种只能通过位置指定而不能通过关键字指定的参数。这可以降低调用代码与参数名称之间的耦合度。这些参数位于 &#x2F; 符号的左侧。</li>
<li>位于 &#x2F; 与 * 之间的参数，可以按位置也可以按关键字指定。</li>
</ul>
<h2 id="第26条-用functools-wraps定义函数修饰器"><a href="#第26条-用functools-wraps定义函数修饰器" class="headerlink" title="第26条  用functools.wraps定义函数修饰器"></a>第26条  用functools.wraps定义函数修饰器</h2><p>修饰器（decorator）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>, <span class="subst">&#123;kwargs!r&#125;</span>) &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;-&gt; <span class="subst">&#123;result!r&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>但上面这样写有个副作用：修饰器返回的那个值，它的名字不叫原来的名字。</p>
<p>可能会干涉那些需要利用introspection（反射）机制运作的工具，如调试器，help，对象序列化器。</p>
<p>解决这个问题可以用functools.wraps，它会将重要的元数据（metadata）全都从内部函数复制到外部函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<h1 id="第四章-推导与生成"><a href="#第四章-推导与生成" class="headerlink" title="第四章  推导与生成"></a>第四章  推导与生成</h1><h2 id="第27条-用列表推导取代map与filter"><a href="#第27条-用列表推导取代map与filter" class="headerlink" title="第27条  用列表推导取代map与filter"></a>第27条  用列表推导取代map与filter</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导</span></span><br><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">even_squres = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导</span></span><br><span class="line">even_squres_dict = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合推导</span></span><br><span class="line">threes_cubed_set = &#123;x**<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第28条-控制推导逻辑的子表达式不要超过两个"><a href="#第28条-控制推导逻辑的子表达式不要超过两个" class="headerlink" title="第28条  控制推导逻辑的子表达式不要超过两个"></a>第28条  控制推导逻辑的子表达式不要超过两个</h2><p>列表推导支持多个子表达式，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</span><br><span class="line">squred = [[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br></pre></td></tr></table></figure>

<p>也可以连用两个 if ，如果在同一层循环内，默认为and关系。</p>
<h2 id="第29条-用赋值表达式消除推导中的重复代码"><a href="#第29条-用赋值表达式消除推导中的重复代码" class="headerlink" title="第29条  用赋值表达式消除推导中的重复代码"></a>第29条  用赋值表达式消除推导中的重复代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">has_bug = &#123;name: get_batches(stock.get(name, <span class="number">0</span>), <span class="number">4</span>)</span><br><span class="line">          <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">          <span class="keyword">if</span> get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面这段代码可以改成：</span></span><br><span class="line">has_bug = &#123;name: batches <span class="keyword">for</span> name <span class="keyword">in</span> order</span><br><span class="line">          <span class="keyword">if</span> (batches := get_batches(stock.get(name, <span class="number">0</span>), <span class="number">8</span>))&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第30条-不要让函数直接返回列表，应该让它逐个生成列表里的值"><a href="#第30条-不要让函数直接返回列表，应该让它逐个生成列表里的值" class="headerlink" title="第30条  不要让函数直接返回列表，应该让它逐个生成列表里的值"></a>第30条  不要让函数直接返回列表，应该让它逐个生成列表里的值</h2><p>案例问题：返回字符串每个单词首字母所对应的下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            result.append(index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>但上述代码有两个缺点：</p>
<ul>
<li>看起来杂乱</li>
<li>必须把所有结果都保存在列表中。如果输入数据特别多，可能耗尽内存。</li>
</ul>
<p>这种函数改为用生成器（generator）实现比较好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_words</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> index + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>生成器函数不用把整个输入值全部读进来，也不用一次就把所有的输出值都算好。</p>
<h2 id="第31条-谨慎地迭代函数所收到的参数"><a href="#第31条-谨慎地迭代函数所收到的参数" class="headerlink" title="第31条  谨慎地迭代函数所收到的参数"></a>第31条  谨慎地迭代函数所收到的参数</h2><p>迭代器只能产生一次结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = ...</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>可以先迭代出结果，再保存。但这样如果输入数据特别多，可能耗尽内存。</p>
<p>可以自定义一个可迭代的容器类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadVisits</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_path</span>):</span></span><br><span class="line">        self.data_path = data_path</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.data_path) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">yield</span> <span class="built_in">int</span>(line)</span><br></pre></td></tr></table></figure>

<h2 id="第32条-考虑用生成器表达式改写数据量较大的列表推导"><a href="#第32条-考虑用生成器表达式改写数据量较大的列表推导" class="headerlink" title="第32条  考虑用生成器表达式改写数据量较大的列表推导"></a>第32条  考虑用生成器表达式改写数据量较大的列表推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">value = [<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">100</span>, <span class="number">57</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">75</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x108993dd0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>生成器表达式之间可以继续迭代组合使用，使用的内存同样不会太多。</p>
<h2 id="第33条-通过yield-from把多个生成器连起来用"><a href="#第33条-通过yield-from把多个生成器连起来用" class="headerlink" title="第33条  通过yield from把多个生成器连起来用"></a>第33条  通过yield from把多个生成器连起来用</h2><p>案例问题：编写程序让图片先快速移动一段时间，再暂停，再慢速移动一段时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">period, speed</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(period):</span><br><span class="line">        <span class="keyword">yield</span> speed</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pause</span>(<span class="params">delay</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(delay):</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span>():</span></span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">4</span>, <span class="number">5.0</span>):</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> pause(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br><span class="line">    <span class="keyword">for</span> delta <span class="keyword">in</span> move(<span class="number">2</span>, <span class="number">3.0</span>):</span><br><span class="line">        <span class="keyword">yield</span> delta</span><br></pre></td></tr></table></figure>

<p>但上述写法animate函数里存在很多重复。可以改写为下面的代码，看上去更清晰，并且速度更快：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate_composed</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">4</span>, <span class="number">5.0</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> pause(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> move(<span class="number">2</span>, <span class="number">3.0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第34条-不要用send给生成器注入数据"><a href="#第34条-不要用send给生成器注入数据" class="headerlink" title="第34条  不要用send给生成器注入数据"></a>第34条  不要用send给生成器注入数据</h2><p>Python的生成器支持send方法，这可以让生成器变成双向通道。send方法可以把参数发给生成器，让它成为上一条yield表达式的求值结果，并将生成器推进到下一条yield表达式，然后把yield表达式右边的值返回给send方法的调用者。然而在一般情况下，我们还是会通过内置的next函数推进生成器，按照这种写法，上一条yield表达式的求值结果总是None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span>():</span></span><br><span class="line">    received = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;received = <span class="subst">&#123;received&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">it = <span class="built_in">iter</span>(my_generator())</span><br><span class="line">output = <span class="built_in">next</span>(it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;output = <span class="subst">&#123;output&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">output = <span class="number">1</span></span><br><span class="line">received = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>因为“send方法可以把参数发给生成器，让它成为上一条yield表达式的求值结果”，所以首次调用send方法时，只能传None。</p>
<p>send与yield from搭配起来使用可能会导致奇怪的结果。通过迭代器向组合起来的生成器输入数据要比send方法方案好。</p>
<h2 id="第35条-不要通过throw变换生成器的状态"><a href="#第35条-不要通过throw变换生成器的状态" class="headerlink" title="第35条  不要通过throw变换生成器的状态"></a>第35条  不要通过throw变换生成器的状态</h2><p>生成器可以把调用者通过throw方法传进来的Exception实例重新抛出。如果调用了这个方法，生成器下次推进时就不会像平常那样，直接走到下一条yield，而是会把传入的异常重新抛出。也可以用try &#x2F; except复合语句把yield包裹起来，异常捕获后不继续抛出异常，那么生成器函数会推进到下一条yield表达式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">except</span> MyError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Got MyError!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">it = my_generator()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(it.throw(MyError(<span class="string">&#x27;test error&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Got MyError!</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>但这种写法比较难懂。凡是想用生成器与异常实现的功能，通常都可以改用异步机制去做。或通过类的__iter__方法实现生成器，并且专门提供一个方法，让调用者通过这个方法来触发这种特殊的状态变换逻辑。</p>
<h2 id="第36条-考虑用itertools拼装迭代器与生成器"><a href="#第36条-考虑用itertools拼装迭代器与生成器" class="headerlink" title="第36条  考虑用itertools拼装迭代器与生成器"></a>第36条  考虑用itertools拼装迭代器与生成器</h2><p>Python内置的itertools模块里有很多函数，可以用来安排迭代器之间的交互关系。实现比较难写的迭代逻辑之前，应该先查看它的文档。下面分三大类列出其中最重要的函数。</p>
<h3 id="连接多个迭代器"><a href="#连接多个迭代器" class="headerlink" title="连接多个迭代器"></a>连接多个迭代器</h3><h4 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h4><p>chain可以把多个迭代器从头到尾连成一个迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.chain([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>制作一个不停输出某个值的迭代器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.repeat(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h4><p>循环输出某段内容之中的各项元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.cycle([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">result = [<span class="built_in">next</span>(it) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><p>tee可以让一个迭代器分裂成多个平行的迭代器，具体个数由第二个参数指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it1, it2, it3 = itertools.tee([<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>], <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it2))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it3))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="zip-longest"><a href="#zip-longest" class="headerlink" title="zip_longest"></a>zip_longest</h4><p>与内置的zip类似，但区别在于，如果源迭代器长度不同，它会用fillvalue参数的值来填补提前耗尽的那些迭代器所留下的空缺。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">normal = <span class="built_in">list</span>(<span class="built_in">zip</span>(keys, values))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zip:        &#x27;</span>, normal)</span><br><span class="line"></span><br><span class="line">it = itertools.zip_longest(keys, values, fillvalue=<span class="string">&#x27;nope&#x27;</span>)</span><br><span class="line">longest = <span class="built_in">list</span>(it)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;zip_longest:&#x27;</span>, longest)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">zip</span>:        [(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>)]</span><br><span class="line">zip_longest:[(<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;nope&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="过滤源迭代器中的元素"><a href="#过滤源迭代器中的元素" class="headerlink" title="过滤源迭代器中的元素"></a>过滤源迭代器中的元素</h3><h4 id="islice"><a href="#islice" class="headerlink" title="islice"></a>islice</h4><p>在不拷贝数据的前提下，按照下标切割源迭代器。可以只给出终点，也可以同时给出起点和终点，还可以指定步进值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">first_five = itertools.islice(values, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;First five: &#x27;</span>, <span class="built_in">list</span>(first_five))</span><br><span class="line"></span><br><span class="line">middle_odds = itertools.islice(values, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Middle odds:&#x27;</span>, <span class="built_in">list</span>(middle_odds))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">First five:  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">Middle odds: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h4 id="takewhile"><a href="#takewhile" class="headerlink" title="takewhile"></a>takewhile</h4><p>takewhile会一直从源迭代器获取元素，直到某元素让测试函数返回False为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">less_than_seven = <span class="keyword">lambda</span> x: x &lt; <span class="number">7</span></span><br><span class="line">it = itertools.takewhile(less_than_seven, values)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<h4 id="dropwhile"><a href="#dropwhile" class="headerlink" title="dropwhile"></a>dropwhile</h4><p>dropwhile会一直跳过元素，直到某元素让测试函数返回False为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">less_than_seven = <span class="keyword">lambda</span> x: x &lt; <span class="number">7</span></span><br><span class="line">it = itertools.dropwhile(less_than_seven, values)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<h4 id="filterfalse"><a href="#filterfalse" class="headerlink" title="filterfalse"></a>filterfalse</h4><p>与内置的filter相反，会逐个输出源迭代器里使得测试函数返回False的那些元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">evens = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">filter_result = <span class="built_in">filter</span>(evens, values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Filter:      &#x27;</span>, <span class="built_in">list</span>(filter_result))</span><br><span class="line"></span><br><span class="line">filter_false_result = itertools.filterfalse(evens, values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Filter false:&#x27;</span>, <span class="built_in">list</span>(filter_false_result))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Filter:       [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">Filter false: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h3 id="用源迭代器中的元素合成新元素"><a href="#用源迭代器中的元素合成新元素" class="headerlink" title="用源迭代器中的元素合成新元素"></a>用源迭代器中的元素合成新元素</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><p>从源迭代器里取出一个元素，并把已经累计的结果与这个元素一起传给表示累加逻辑的函数，然后输出那个函数的计算结果，并把结果当成新的累计值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">sum_reduce = itertools.accumulate(values)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sum:   &#x27;</span>, <span class="built_in">list</span>(sum_reduce))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_modulo_20</span>(<span class="params">first, second</span>):</span></span><br><span class="line">    output = first + second</span><br><span class="line">    <span class="keyword">return</span> output % <span class="number">20</span></span><br><span class="line"></span><br><span class="line">modulo_reduce = itertools.accumulate(values, sum_modulo_20)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Modulo:&#x27;</span>, <span class="built_in">list</span>(modulo_reduce))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Sum:    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">55</span>]</span><br><span class="line">Modulo: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure>

<h4 id="product"><a href="#product" class="headerlink" title="product"></a>product</h4><p>product会从一个或多个源迭代器里获取元素，并计算笛卡尔积，可以取代那种多层嵌套的列表推导代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">single = itertools.product([<span class="number">1</span>, <span class="number">2</span>], repeat=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Single:  &#x27;</span>, <span class="built_in">list</span>(single))</span><br><span class="line"></span><br><span class="line">multiple = itertools.product([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Multiple:&#x27;</span>, <span class="built_in">list</span>(multiple))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Single:   [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br><span class="line">Multiple: [(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h4><p>permutations会考虑源迭代器所能给出的全部元素，并逐个输出由其中N个元素形成的每种有序排列方式，元素相同但顺序不同，算作两种排列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h4><p>combinations会考虑源迭代器所能给出的全部元素，并逐个输出由其中N个元素形成的每种无序组合方式，元素相同但顺序不同，算作同一种组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="combinations-with-replacement"><a href="#combinations-with-replacement" class="headerlink" title="combinations_with_replacement"></a>combinations_with_replacement</h4><p>combinations_with_replacement与combinations类似，但它允许同一个元素在组合里多次出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it = itertools.combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(it))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">2</span>), </span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure>

<h1 id="第五章-类与接口"><a href="#第五章-类与接口" class="headerlink" title="第五章  类与接口"></a>第五章  类与接口</h1><p>Python完全支持继承多态封装等各种机制。熟悉类与接口的用法，可以帮助我们写出易于维护的代码。</p>
<h2 id="第37条-用组合起来的类来实现多层结构，不要用嵌套的内置类型"><a href="#第37条-用组合起来的类来实现多层结构，不要用嵌套的内置类型" class="headerlink" title="第37条  用组合起来的类来实现多层结构，不要用嵌套的内置类型"></a>第37条  用组合起来的类来实现多层结构，不要用嵌套的内置类型</h2><p>遇到比较复杂的需求，那么不要再嵌套字典、元组、集合等内置类型，而是应该编写一批新类并让这些类形成一套体系。</p>
<h3 id="把多层嵌套的内置类型重构为类体系"><a href="#把多层嵌套的内置类型重构为类体系" class="headerlink" title="把多层嵌套的内置类型重构为类体系"></a>把多层嵌套的内置类型重构为类体系</h3><p>使用具名元组（namedtuple）定义小型的类以表示不可变的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Grade = namedtuple(<span class="string">&#x27;Grade&#x27;</span>, (<span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>可通过位置参数构造，也可通过关键字参数构造。方便后期改写为普通的类。</p>
<p>namedtuple的局限：</p>
<ul>
<li>无法指定默认参数值</li>
<li>属性值仍然可以通过数字下标与迭代访问</li>
</ul>
<h2 id="第38条-让简单的接口接受函数，而不是类的实例"><a href="#第38条-让简单的接口接受函数，而不是类的实例" class="headerlink" title="第38条  让简单的接口接受函数，而不是类的实例"></a>第38条  让简单的接口接受函数，而不是类的实例</h2><p>许多内置的API允许传入某个函数来定制它的行为，这种函数可以叫做挂钩（hook）。API在执行过程中，会回调（call back）这些挂钩函数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Charles&#x27;</span>, <span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>]</span><br><span class="line">names.sort(key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Plato&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Charles&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>其他语言中hook可能会用抽象类定义，但在Python中，许多hook都是无状态的函数（创建时不需要参数，也没有任何内存），带有明确的参数与返回值。</p>
<p>某个类定义了__call__特殊方法那么就是callable，能够像函数那样调用。</p>
<p>如果想用函数来维护状态，可以考虑定义一个带有__call__方法的新类，而不要用有状态的闭包实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterCountMissing</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.added = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.added += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter = BetterCountMissing()</span><br><span class="line"><span class="keyword">assert</span> counter() == <span class="number">0</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">callable</span>(counter)</span><br></pre></td></tr></table></figure>

<h2 id="第39条-通过-classmethod多态来构造同一体系中的各类对象"><a href="#第39条-通过-classmethod多态来构造同一体系中的各类对象" class="headerlink" title="第39条  通过@classmethod多态来构造同一体系中的各类对象"></a>第39条  通过@classmethod多态来构造同一体系中的各类对象</h2><p>在Python中，不仅对象支持多态，类也支持多态。（这里的多态是指在超类上调用方法，实际触发的是子类的同名方法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericInputData</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span>(<span class="params">cls, config</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathInputData</span>(<span class="params">GenericInputData</span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_inputs</span>(<span class="params">cls, config</span>):</span></span><br><span class="line">        data_dir = config[<span class="string">&#x27;data_dir&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(data_dir):</span><br><span class="line">            <span class="keyword">yield</span> cls(os.path.join(data_dir, name))</span><br></pre></td></tr></table></figure>

<p>Python只允许每个类有一个构造方法，也就是__init__方法。如果想在超类中用通用的代码构造子类实例，可以考虑@classmethod方法，并在里面用cls(…)的形式构造具体的子类对象。</p>
<h2 id="第40条-通过super初始化超类"><a href="#第40条-通过super初始化超类" class="headerlink" title="第40条  通过super初始化超类"></a>第40条  通过super初始化超类</h2><p>以前有种简单的写法，能在子类里面执行超类的初始化逻辑（直接在超类名称上调用__init__方法并把子类实例传进去）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        MyBaseClass.__init__(self, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>但是容易出现问题：</p>
<ul>
<li>超类的构造逻辑不一定会按照它们在子类class语句中的声明顺序执行，而是依照__init__的调用顺序</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesTwo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusFive</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value += <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWay</span>(<span class="params">MyBaseClass, PlusFive, TimesTwo</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        TimesTwo.__init__(self)</span><br><span class="line">        PlusFive.__init__(self)</span><br><span class="line"></span><br><span class="line">bar = AnotherWay(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(bar.value)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>无法正确处理菱形继承</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesSeven</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        self.value *= <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusNine</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        MyBaseClass.__init__(self, value)</span><br><span class="line">        self.value += <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThisWay</span>(<span class="params">TimesSeven, PlusNine</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        TimesSeven.__init__(self, value)</span><br><span class="line">        PlusNine.__init__(self, value)</span><br><span class="line"></span><br><span class="line">foo = ThisWay(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Should be (5 * 7) + 9 = 44 but is&#x27;</span>, foo.value)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Should be (<span class="number">5</span> * <span class="number">7</span>) + <span class="number">9</span> = <span class="number">44</span> but <span class="keyword">is</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>当ThisWay调用第二个超类的__init__时，那个方法会再度触发MyBaseClass的__init__，导致self.value重新变成5。为了解决这些问题，Python内置了super函数并且规定了标准的方法解析顺序（method resolution order，MRO）。super能够确保菱形继承体系内共同超类只初始化一次。MRO可以确定超类之间的初始化顺序，它遵循C3线性化算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBaseClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesSevenCorrect</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(value)</span><br><span class="line">        self.value *= <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusNineCorrect</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(value)</span><br><span class="line">        self.value += <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span>(<span class="params">TimesSevenCorrect, PlusNineCorrect</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(value)</span><br><span class="line"></span><br><span class="line">foo = GoodWay(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Should be 7 * (5 + 9) = 98 but is&#x27;</span>, foo.value)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Should be <span class="number">7</span> * (<span class="number">5</span> + <span class="number">9</span>) = <span class="number">98</span> but <span class="keyword">is</span> <span class="number">98</span></span><br></pre></td></tr></table></figure>

<p>超类之间的初始化顺序，要由子类的MRO确定，它可以通过mro方法查询：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mro_str = <span class="string">&#x27;\n&#x27;</span>.join(<span class="built_in">repr</span>(cls) <span class="keyword">for</span> cls <span class="keyword">in</span> GoodWay.mro())</span><br><span class="line"><span class="built_in">print</span>(mro_str)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">GoodWay</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">TimesSevenCorrect</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">PlusNineCorrect</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyBaseClass</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> &#x27;<span class="title">object</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>super函数也可以用双参数的形式调用。第一个参数表示从这个类型开始（不含该类型本身）按照方法解析顺序（MRO）向上搜索，而解析顺序则要由第二个参数所在类型的_mro_决定。例如，按照下面这种写法，如果在super所返回的内容上调用__init__.方法，那么程序会从ExplicitTrisect类型开始（不含该类型本身）按照MRO向上搜索，直至找到这样的__init__方法为止，而解析顺序是由第二个参数（self）所属的类型（ExplicitTrisect）决定的，所以解析顺序是ExplicitTrisect -&gt; MyBaseClass -&gt; object。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExplicitTrisect</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ExplicitTrisect, self).__init__(value)</span><br><span class="line">        self.value /= <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>__init__方法里面通过super初始化实例时，不需要采用双参数的形式，而是可以直接采用不带参数的写法调用super，这样Python编译器会自动将__class__和self当成参数传递进去。所以，下面这两种写法跟刚才那种写法是同一个意思。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticTrisect</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(__class__, self).__init__(value)</span><br><span class="line">        self.value /= <span class="number">3</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplicitTrisect</span>(<span class="params">MyBaseClass</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(value)</span><br><span class="line">        self.value /= <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="第41条-考虑用mix-in类来表示可组合的功能"><a href="#第41条-考虑用mix-in类来表示可组合的功能" class="headerlink" title="第41条  考虑用mix-in类来表示可组合的功能"></a>第41条  考虑用mix-in类来表示可组合的功能</h2><p>Python支持多重继承，但应该尽量少用。如果既要通过多重继承来方便地封装逻辑，又想避开可能出现的问题，应该把有待继承的类写成min-in类。这种类只提供一小套方法给子类去沿用，而不定义自己实例级别的属性，也不需要__init__构造函数。</p>
<p>案例问题：把内存中的Python对象表示成字典形式以便做序列化处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToDictMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_dict</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._traverse_dict(self.__dict__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_traverse_dict</span>(<span class="params">self, instance_dict</span>):</span></span><br><span class="line">        output = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> instance_dict.items():</span><br><span class="line">            output[key] = self._traverse(key, value)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_traverse</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, ToDictMixin):</span><br><span class="line">            <span class="keyword">return</span> value.to_dict()</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(value, <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">return</span> self._traverse_dict(value)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(value, <span class="built_in">list</span>):</span><br><span class="line">            <span class="keyword">return</span> [self._traverse(key, i) <span class="keyword">for</span> i <span class="keyword">in</span> value]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">hasattr</span>(value, <span class="string">&#x27;_dict_&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> self._traverse_dict(value.__dict__)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>下面以二叉树为例，演示如何使表示二叉树的BinaryTree类具备刚才那个mix-in所提供的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>(<span class="params">ToDictMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = BinaryTree(<span class="number">10</span>,</span><br><span class="line">    left=BinaryTree(<span class="number">7</span>, right=BinaryTree(<span class="number">9</span>)),</span><br><span class="line">    right=BinaryTree(<span class="number">13</span>, left=BinaryTree(<span class="number">11</span>)))</span><br><span class="line"><span class="built_in">print</span>(tree.to_dict())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">&#x27;left&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">7</span>, </span><br><span class="line">          <span class="string">&#x27;left&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line">          <span class="string">&#x27;right&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;left&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;right&#x27;</span>: <span class="literal">None</span>&#125;&#125;, </span><br><span class="line"> <span class="string">&#x27;right&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">13</span>, </span><br><span class="line">           <span class="string">&#x27;left&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;left&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;right&#x27;</span>: <span class="literal">None</span>&#125;, </span><br><span class="line">           <span class="string">&#x27;right&#x27;</span>: <span class="literal">None</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>mix-in最妙的地方在于，子类既可以沿用它所提供的功能，又可以对其中一些地方做自己的处理。</p>
<p>例如，我们从普通的二叉树（BinaryTree）派生了一个子类，让这种特殊的BinaryTreeWithParent二叉树能够把指向上级节点的引用保留下来。但问题是，这种二叉树的to_dict方法是从ToDictMixin继承来的，它所触发的_traverse方法，在面对循环引用时，会无休止地递归下去。</p>
<p>为了避免无限循环，可以覆盖BinaryTreeWithParent._traverse方法，让它对指向上级节点的引用做专门的处理，对其他值则沿用继承的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeWithParent</span>(<span class="params">BinaryTree</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value, left=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 right=<span class="literal">None</span>, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(value, left=left, right=right)</span><br><span class="line">        self.parent = parent</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_traverse</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isinstance</span>(value, BinaryTreeWithParent) <span class="keyword">and</span></span><br><span class="line">                key == <span class="string">&#x27;parent&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> value.value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>()._traverse(key, value)</span><br><span class="line"></span><br><span class="line">root = BinaryTreeWithParent(<span class="number">10</span>)</span><br><span class="line">root.left = BinaryTreeWithParent(<span class="number">7</span>, parent=root)</span><br><span class="line">root.left.right = BinaryTreeWithParent(<span class="number">9</span>, parent=root.left)</span><br><span class="line"><span class="built_in">print</span>(root.to_dict())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">10</span>, </span><br><span class="line"> <span class="string">&#x27;left&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">7</span>, </span><br><span class="line">          <span class="string">&#x27;left&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line">          <span class="string">&#x27;right&#x27;</span>: &#123;<span class="string">&#x27;value&#x27;</span>: <span class="number">9</span>, </span><br><span class="line">                    <span class="string">&#x27;left&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line">                    <span class="string">&#x27;right&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line">                    <span class="string">&#x27;parent&#x27;</span>: <span class="number">7</span>&#125;, </span><br><span class="line">          <span class="string">&#x27;parent&#x27;</span>: <span class="number">10</span>&#125;, </span><br><span class="line"> <span class="string">&#x27;right&#x27;</span>: <span class="literal">None</span>, </span><br><span class="line"> <span class="string">&#x27;parent&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<p>多个mix-in可以组合起来使用。</p>
<h2 id="第42条-优先考虑用public属性表示应受保护的数据，不要用private属性表示"><a href="#第42条-优先考虑用public属性表示应受保护的数据，不要用private属性表示" class="headerlink" title="第42条  优先考虑用public属性表示应受保护的数据，不要用private属性表示"></a>第42条  优先考虑用public属性表示应受保护的数据，不要用private属性表示</h2><p>Python的类属性只有两种访问级别，public与private：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.public_field = <span class="number">5</span></span><br><span class="line">        self.__private_field = <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_private_field</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__private_field</span><br></pre></td></tr></table></figure>

<p>private字段只给这个类自己使用，不给子类以及其他。</p>
<p>实现方式为变换属性名称，如上例中__private_field则变为_MyObject__private_field。</p>
<ul>
<li>Python编译器无法绝对禁止外界访问 private属性。</li>
<li>从一开始就应该考虑允许其他类能继承这个类，并利用其中的内部API与属性去实现更多功能，而不是把它们藏起来。</li>
<li>把需要保护的数据设计成protected字段，并用文档加以解释，而不要通过private属性限制访问。</li>
<li>只有在子类不受控制且名称有可能与超类冲突时，才可以考虑给超类设计private属性。</li>
</ul>
<h2 id="第43条-自定义的容器类型应该从collections-abc继承"><a href="#第43条-自定义的容器类型应该从collections-abc继承" class="headerlink" title="第43条  自定义的容器类型应该从collections.abc继承"></a>第43条  自定义的容器类型应该从collections.abc继承</h2><p>如果要编写的新类比较简单，那么可以直接从Python的容器类型里面继承。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrequencyList</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, members</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(members)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequency</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self:</span><br><span class="line">            count[item] = count.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>为了方便定制容器，Python内置的collections.abc模块定义了一系列抽象基类，把每种容器类型应该提供的所有常用方法都写了出来，只需要继承这些抽象基类。同时，如果忘了实现某些必备的方法，程序会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> <span class="type">Sequence</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="type">Sequence</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="第六章-元类与属性"><a href="#第六章-元类与属性" class="headerlink" title="第六章  元类与属性"></a>第六章  元类与属性</h1><p>元类能够拦截Python的class语句，让系统每次定义类的时候，都能实现某些特殊的行为。</p>
<p>除了元类，Python还可以动态地定制属性访问操作。</p>
<h2 id="第44条-用纯属性与修饰器取代旧式的setter与getter方法"><a href="#第44条-用纯属性与修饰器取代旧式的setter与getter方法" class="headerlink" title="第44条  用纯属性与修饰器取代旧式的setter与getter方法"></a>第44条  用纯属性与修饰器取代旧式的setter与getter方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VoltageResistance</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ohms</span>):</span></span><br><span class="line">        self.ohms = ohms</span><br><span class="line">        self._voltage = <span class="number">0</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voltage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._voltage</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @voltage.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">voltage</span>(<span class="params">self, voltage</span>):</span></span><br><span class="line">        self._voltage = voltage</span><br><span class="line">        self.current = self._voltage / self.ohms</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._ohms</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ohms.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span>(<span class="params">self, ohms</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;_ohms&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;Ohms is immutable!&#x27;</span>)</span><br><span class="line">        self._ohms = ohms</span><br></pre></td></tr></table></figure>

<p>@property最大的缺点是，通过它而编写的属性取及属性设置方法只能由子类共享。与此无关的类不能共用这份逻辑。但是没关系，Pvthon还支持描述符（descriptor，参见第46条)，我们可以利用这种机制把早前编写的属性获取与属性设置逻辑复用到其他许多地方。</p>
<ul>
<li>给新类定义接口时，应该先从简单的public属性写起，避免定义setter与 getter方法。</li>
<li>如果在访问属性时确实有必要做特殊的处理，那就通过@property来定义获取属性与设置属性的方法。</li>
<li>实现@property方法时，应该遵循最小惊讶原则，不要引发奇怪的副作用。</li>
<li>@property方法必须执行得很快。复杂或缓慢的任务，尤其是涉及IO或者会引发副作用的那些任务，还是用普通的方法来实现比较好。</li>
</ul>
<h2 id="第45条-考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码"><a href="#第45条-考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码" class="headerlink" title="第45条  考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码"></a>第45条  考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</h2><ul>
<li>可以利用 @property给已有的实例属性增加新的功能。</li>
<li>可以利用@property 逐渐改善数据模型而不影响已经写好的代码。</li>
<li>如果发现@property使用太过频繁，那可能就该考虑重构这个类了，同时按照旧办法使用这个类的那些代码可能也要重构。</li>
</ul>
<h2 id="第46条-用描述符来改写需要复用的-property"><a href="#第46条-用描述符来改写需要复用的-property" class="headerlink" title="第46条  用描述符来改写需要复用的@property"></a>第46条  用描述符来改写需要复用的@property</h2><p>Python内置的@property最大的缺点就是不方便复用。我们不能把它修饰的方法所使用的逻辑，套用在同一个类的其他属性上面，也不能在无关的类里面复用。</p>
<p>这样的功能最好通过描述符实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> WeakKeyDictionary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 用WeakKeyDictionary是让系统自动处理内存泄漏问题</span></span><br><span class="line">        <span class="comment"># 用dict是要把每个Exam实例在这个属性上的取值都记录下来</span></span><br><span class="line">        self._value = WeakKeyDictionary()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, instance_type</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self._value.get(instance, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Grade must be between 0 and 100&#x27;</span>)</span><br><span class="line">        self._value[instance] = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></span><br><span class="line">    math_grade = Grade()</span><br><span class="line">    writing_grade = Grade()</span><br><span class="line">    science_grade = Grade()</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></span><br><span class="line">    math_grade = Grade()</span><br><span class="line">    writing_grade = Grade()</span><br><span class="line">    science_grade = Grade()</span><br></pre></td></tr></table></figure>

<h2 id="第47条-针对惰性属性使用-getattr-、-getattribute-及-setattr"><a href="#第47条-针对惰性属性使用-getattr-、-getattribute-及-setattr" class="headerlink" title="第47条  针对惰性属性使用__getattr__、__getattribute__及__setattr__"></a>第47条  针对惰性属性使用__getattr__、__getattribute__及__setattr__</h2><p>如果类中定义了__getattr__，那么每当访问该类对象属性，而且实例字典里又找不到这个属性时，系统就会触发__getattr__方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyRecord</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.exists = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        value = <span class="string">f&#x27;Value for <span class="subst">&#123;item&#125;</span>&#x27;</span></span><br><span class="line">        <span class="built_in">setattr</span>(self, item, value)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">data = LazyRecord()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before:&#x27;</span>, data.__dict__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;foo:   &#x27;</span>, data.foo)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After :&#x27;</span>, data.__dict__)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: &#123;<span class="string">&#x27;exists&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">foo:    Value <span class="keyword">for</span> foo</span><br><span class="line">After : &#123;<span class="string">&#x27;exists&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;Value for foo&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>__getattribute__方法只要访问对象中的属性就会触发，无论是否在__dict__字典里。</p>
<p>__setattr__方法只要给实例中的属性赋值就会触发。</p>
<p>注意：在实现__getattribute__方法与__setattr__方法时，如果要使用本对象的普通属性，那么应该通过super()也就是object来使用，以避免无限递归。</p>
<h2 id="第48条-用-init-subclass-验证子类写得是否正确"><a href="#第48条-用-init-subclass-验证子类写得是否正确" class="headerlink" title="第48条  用__init_subclass__验证子类写得是否正确"></a>第48条  用__init_subclass__验证子类写得是否正确</h2><p>元类最简单的一种用法是验证某个类定义得是否正确。如果要构建一套比较复杂的类体系，那我们可能得确保这套体系中的类采用的都是同一种风格，为此我们可能需要判断这些类有没有重写必要的方法，或者判断类属性之间的关系是否合理。元类提供了一种可靠的手段，只要根据这个元类来定义新类，就能用元类中的验证逻辑核查新类的代码写得是否正确。</p>
<p>一般来说，我们会在类的__init__方法里面检查新对象构造得是否正确（参见第44条）。但有的时候，整个类的写法可能都是错的，而不单单是该类的某个对象构造得有问题，所以我们想尽早拦住这种错误。例如，当程序刚刚启动并把包含这个类的模块加载进来时，我们就想验证这个类写得对不对，此时便可利用元类来实现。</p>
<p>在讲解如何用自定义的元类验证子类之前，我们首先必须明白元类的标准用法。元类应该从type之中继承。在默认情况下，系统会把通过这个元类所定义的其他类发送给元类的__new__方法，让该方法知道那个类的class语句是怎么写的。下面就定义这样一个元类，如果用户通过这个元类来定义其他类，那么在那个类真正构造出来之前，我们可以先在__new__里面观察到它的写法并做出修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, class_dict</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;* Running <span class="subst">&#123;mcs&#125;</span>.__new__ for <span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Bases:&#x27;</span>, bases)</span><br><span class="line">        <span class="built_in">print</span>(class_dict)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(mcs, name, bases, class_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params">metaclass=Meta</span>):</span></span><br><span class="line">    stuff = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>(<span class="params">MyClass</span>):</span></span><br><span class="line">    other = <span class="number">567</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">* Running &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Meta</span>&#x27;&gt;.<span class="title">__new__</span> <span class="title">for</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"><span class="title">Bases</span>:</span> ()</span><br><span class="line">&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;MyClass&#x27;</span>, <span class="string">&#x27;stuff&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;foo&#x27;</span>: &lt;function MyClass.foo at <span class="number">0x000001870F665DA0</span>&gt;&#125;</span><br><span class="line">* Running &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">Meta</span>&#x27;&gt;.<span class="title">__new__</span> <span class="title">for</span> <span class="title">MySubClass</span></span></span><br><span class="line"><span class="class"><span class="title">Bases</span>:</span> (&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">__main__</span>.<span class="title">MyClass</span>&#x27;&gt;,)</span></span><br><span class="line"><span class="class">&#123;&#x27;<span class="title">__module__</span>&#x27;:</span> <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>: <span class="string">&#x27;MySubClass&#x27;</span>, <span class="string">&#x27;other&#x27;</span>: <span class="number">567</span>, <span class="string">&#x27;bar&#x27;</span>: &lt;function MySubClass.bar at <span class="number">0x000001870F665D00</span>&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在元类的__new__方法里而添加―些代码，用来判断根据这个元类所定义的类的各项参数是否合理。例如，要用不同的类来表示边数不同的多边形（polygon)。如果把这些类都纳入同一套体系，那么可以定义这样一个元类，让该体系内的所有类都受它约束。我们在这个元类的__new__里面检查那些类的边数（sides是否有效。注意，不要把检查逻辑运用到类体系的顶端，也就是基类Polygon上面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidatePolygon</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span> (<span class="params">mcs, name, bases, class_dict</span>):</span></span><br><span class="line">        <span class="comment">#Only validate subc1asses of the Polygon class</span></span><br><span class="line">        <span class="keyword">if</span> bases:</span><br><span class="line">            <span class="keyword">if</span> class_dict[<span class="string">&#x27;sides&#x27;</span>] &lt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Polygons need 3+ sides &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(mcs, name, bases, class_dict)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span>(<span class="params">metaclass=ValidatePolygon</span>):</span></span><br><span class="line">    sides = <span class="literal">None</span>    <span class="comment"># Must be specified by subclasses</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interior_angles</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (cls.sides - <span class="number">2</span>) * <span class="number">180</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>(<span class="params">Polygon</span>):</span></span><br><span class="line">    sides = <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>(<span class="params">Polygon</span>):</span></span><br><span class="line">    sides = <span class="number">4</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before class&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>(<span class="params">Polygon</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Before sides&#x27;</span>)</span><br><span class="line">    sides = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;After sides&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After class&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">Before</span> <span class="title">sides</span></span></span><br><span class="line"><span class="class"><span class="title">After</span> <span class="title">sides</span></span></span><br><span class="line"><span class="class"><span class="title">Traceback</span> (<span class="params">most recent call last</span>):</span></span><br><span class="line">	...</span><br><span class="line">ValueError: Polygons need <span class="number">3</span>+ sides </span><br></pre></td></tr></table></figure>

<p>这样一项基本的任务竟然要写这么多代码才能实现。好在 Python 3.6引人了一种简化的写法，能够直接通过__init_subclass__这个特殊的类方法实现相同的功能，这样就不用专门定义元类了。下面我们改用这个机制来实现与刚才相同的验证逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterPolygon</span>:</span></span><br><span class="line">    sides = <span class="literal">None</span>    <span class="comment"># Must be specified by subclasses</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_subclass__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init_subclass__()</span><br><span class="line">        <span class="keyword">if</span> cls.sides &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Polygons need 3+ sides&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interior_angles</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (cls.sides - <span class="number">2</span>) * <span class="number">180</span></span><br></pre></td></tr></table></figure>

<p>现在的代码简短多了，完全不需要定义ValidatePolygon这样一个元类。</p>
<ul>
<li>如果某个类是根据元类所定义的，那么当系统抑该类的class语句体全部处理完之后，就会将这个类的写法告诉元类的__new__方法。</li>
<li>可以利用元类在类创建完成前检视或修改开发者根据这个元类所定义的其他类，但这种机制通常显得有点笨重。</li>
<li>__init_subclass__能够用来检查子类定义得是否合理，如果不合理，那么可以提前报错，让程序无法创建出这种子类的对象。</li>
<li>在分层的或者涉及多重继承的类体系里面，一定别忘了在你写的这些类的__init_subclass__内通过super()来调用超类的__init_subclass__方法，以便按照正确的顺序触发各类的验证逻辑。</li>
</ul>
<h2 id="第49条-用-init-subclass-记录现有的子类"><a href="#第49条-用-init-subclass-记录现有的子类" class="headerlink" title="第49条  用__init_subclass__记录现有的子类"></a>第49条  用__init_subclass__记录现有的子类</h2><ul>
<li>类注册（Class registration)是个相当有用的模式，可以用来构建模块式的Python程序。</li>
<li>我们可以通过基类的元类把用户从这个基类派生出来的子类自动注册给系统。</li>
<li>利用元类实现类注册可以防止由于用户忘记注册而导致程序出现问题。</li>
<li>优先考虑通过__init_subclass__实现自动注册，而不要用标准的元类机制来实现，因为__init_subclass__更清晰，更便于初学者理解。</li>
</ul>
<h2 id="第50条-用-set-name-给类属性加注解"><a href="#第50条-用-set-name-给类属性加注解" class="headerlink" title="第50条  用__set_name__给类属性加注解"></a>第50条  用__set_name__给类属性加注解</h2><p>有了元类、DatabaseRow基类以及修改过的Field描述符，我们在给客户类定义字段时，就不用手工传入字段名了，代码也不像之前那样冗余了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, class_dict</span>):</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> class_dict.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, Field):</span><br><span class="line">                value.name = key</span><br><span class="line">                value.internal_name = <span class="string">&#x27;_&#x27;</span> + key</span><br><span class="line">            cls = <span class="built_in">type</span>.__new__(mcs, name, bases, class_dict)</span><br><span class="line">            <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># These wi11be assigned by the metaclass</span></span><br><span class="line">        self.name = <span class="literal">None</span></span><br><span class="line">        self.internal_name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, instance_type</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(instance, self.internal_name, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">setattr</span>(instance, self.internal_name, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseRow</span>(<span class="params">metaclass=Meta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有些重复</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span></span><br><span class="line">    first_name = Field(<span class="string">&#x27;first_name&#x27;</span>)</span><br><span class="line">    last_name = Field(<span class="string">&#x27;last_name&#x27;</span>)</span><br><span class="line">    prefix = Field(<span class="string">&#x27;prefix&#x27;</span>)</span><br><span class="line">    suffix = Field(<span class="string">&#x27;suffix&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改成下面这种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterCustomer</span>(<span class="params">DatabaseRow</span>):</span></span><br><span class="line">    first_name = Field()</span><br><span class="line">    last_name = Field()</span><br><span class="line">    prefix = Field()</span><br><span class="line">    suffix = Field()</span><br></pre></td></tr></table></figure>

<p>但这个方法的缺点是，要想在类中声明Field字段，这个类必须从DatabaseRow继承。假如忘了或者结构上不方便这样继承，那么代码就无法正常运行。</p>
<p>这个问题可以通过给描述符定义__set_name__特殊方法来解决。这是Python 3.6引入的新功能：如果某个类用这种描述符的实例来定义字段，那么系统就会在描述符上面触发这个特殊方法。系统会把采用这个描述符实例作字段的那个类以及字段的名称，当成参数传给__set_name__。下面我们将 Meta.__new__之中的逻辑移动到Field描述符元类__set_name__里面，这样一来，就不用定义元类了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># These wi11be assigned by the metaclass</span></span><br><span class="line">        self.name = <span class="literal">None</span></span><br><span class="line">        self.internal_name = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set_name__</span>(<span class="params">self, owner, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.internal_name = <span class="string">&#x27;_&#x27;</span> + name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, instance_type</span>):</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(instance, self.internal_name, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="built_in">setattr</span>(instance, self.internal_name, value)</span><br></pre></td></tr></table></figure>

<ul>
<li>我们可以通过元类把利用这个元类所定义的其他类拦截下来，从而在程序开始使用那些类之前，先对其中定义的属性做出修改。</li>
<li>描述符与元类搭配起来，可以形成一套强大的机制，让我们既能采用声明式的写法来定义行为，又能在程序运行时检视这个行为的具体执行情况。</li>
<li>你可以给描述符定义__set_name__方法，让系统把使用这个描述符做属性的那个类以及它在类里的属性名通过方法的参数告诉你。</li>
<li>用描述符直接操纵每个实例的属性字典，要比把所有实例的属性都放到一份字典里更好，因为后者要求我们必须使用weakref内置模块之中的特殊字典来记录每个实例的属性值以防止内存泄漏。</li>
</ul>
<h2 id="第51条-优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类"><a href="#第51条-优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类" class="headerlink" title="第51条  优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类"></a>第51条  优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</h2><p>尽管元类允许我们用各种方式定制其他类的创建逻辑，但有些情况它未必能处理得很好。例如，要写一个辅助函数来修饰类中的每个方法，把这些方法执行时所用的参数，返回值以及抛出的异常都处理好，以便调试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace_func</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(func, <span class="string">&#x27;tracing&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            result = e</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;args!r&#125;</span>, <span class="subst">&#123;kwargs!r&#125;</span>) -&gt; &#x27;</span></span><br><span class="line">                  <span class="string">f&#x27;<span class="subst">&#123;result!r&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    wrapper.tracing = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line"><span class="meta">    @trace_func</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @trace_func</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @trace_func</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__getitem__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>但这样必须在子类中把需要受@trace_func修饰的方法全都重写一遍，即便子类只想沿用超类的实现方式。</p>
<p>解决这个问题，其中一个办法是通过元类自动修饰那个类的所有方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">trace_types = (</span><br><span class="line">    types.MethodType,</span><br><span class="line">    types.FunctionType,</span><br><span class="line">    types.BuiltinFunctionType,</span><br><span class="line">    types.BuiltinMethodType,</span><br><span class="line">    types.MethodDescriptorType,</span><br><span class="line">    types.ClassMethodDescriptorType</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">mcs, name, bases, class_dict</span>):</span></span><br><span class="line">        class_ = <span class="built_in">super</span>().__new__(mcs, name, bases, class_dict)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">dir</span>(class_):</span><br><span class="line">            value = <span class="built_in">getattr</span>(class_, key)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, trace_types):</span><br><span class="line">                wrapped = trace_func(value)</span><br><span class="line">                <span class="built_in">setattr</span>(class_, key, wrapped)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> class_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceDict</span>(<span class="params"><span class="built_in">dict</span>, metaclass=TraceMeta</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但元类之间很难组合，而类修饰器比较灵活，它们可以施加在同一个类上，并且不会发生冲突。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span>(<span class="params">class_</span>):</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">dir</span>(class_):</span><br><span class="line">        value = <span class="built_in">getattr</span>(class_, key)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, trace_types):</span><br><span class="line">            wrapped = trace_func(value)</span><br><span class="line">            <span class="built_in">setattr</span>(class_, key, wrapped)</span><br><span class="line">    <span class="keyword">return</span> class_</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="第七章-并发与并行"><a href="#第七章-并发与并行" class="headerlink" title="第七章  并发与并行"></a>第七章  并发与并行</h1><h2 id="第52条-用subprocess管理子进程"><a href="#第52条-用subprocess管理子进程" class="headerlink" title="第52条  用subprocess管理子进程"></a>第52条  用subprocess管理子进程</h2><p>Python里面有许多方法都可以运行子进程，其中最好的办法是通过内置的subprocess模块来管理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [<span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;Hello from the child&#x27;</span>],</span><br><span class="line">    capture_output=<span class="literal">True</span>,</span><br><span class="line">    encoding=<span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result.check_returncode()</span><br><span class="line"><span class="built_in">print</span>(result.stdout)</span><br></pre></td></tr></table></figure>

<p>子进程可以独立于父进程运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working...&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit status&#x27;</span>, proc.poll())</span><br></pre></td></tr></table></figure>

<p>把子进程从父进程剥离，可以让程序平行地运行多条子进程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">sleep_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">    sleep_procs.append(proc)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> sleep_procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">delta = end - start</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1.05</span>s</span><br></pre></td></tr></table></figure>

<p>还可以把数据通过管道发送给子进程运行的外部命令，然后将那条命令的输出结果获取到程序中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_encrypt</span>(<span class="params">data</span>):</span></span><br><span class="line">    env = os.environ.copy()</span><br><span class="line">    env[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;zkf5cve|ce\e*-$^V@d23&#x27;</span></span><br><span class="line">    proc = subprocess.Popen(</span><br><span class="line">        [<span class="string">&#x27;openssl&#x27;</span>, <span class="string">&#x27;enc&#x27;</span>, <span class="string">&#x27;-des3&#x27;</span>, <span class="string">&#x27;-pass&#x27;</span>, <span class="string">&#x27;env:password&#x27;</span>],</span><br><span class="line">        env=env,</span><br><span class="line">        stdin=subprocess.PIPE,</span><br><span class="line">        stdout=subprocess.PIPE</span><br><span class="line">    )</span><br><span class="line">    proc.stdin.write(data)</span><br><span class="line">    proc.stdin.flush()</span><br><span class="line">    <span class="keyword">return</span> proc</span><br></pre></td></tr></table></figure>

<p>这些平行运行的子进程还可以分别与另一套平行的子进程对接，形成许多条平行的管道。</p>
<p>在调用communicate方法时可以指定timeout参数，用来停掉不正常的子进程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;10&#x27;</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    proc.communicate(timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">    proc.terminate()</span><br><span class="line">    proc.wait()</span><br></pre></td></tr></table></figure>

<h2 id="第53条-可以用线程执行阻塞式I-O，但不要用它做并行计算"><a href="#第53条-可以用线程执行阻塞式I-O，但不要用它做并行计算" class="headerlink" title="第53条  可以用线程执行阻塞式I&#x2F;O，但不要用它做并行计算"></a>第53条  可以用线程执行阻塞式I&#x2F;O，但不要用它做并行计算</h2><p>CPython的全局解释器锁（Global Interpreter Lock，GIL）限制，无法实现多核心并行计算。（笔者注：在2023年7月。<strong>Python 团队已经正式接受了删除 GIL 的这个提议，并将其设置为可选模式</strong>，但等到彻底去除GIL估计还有5年的时间）</p>
<ul>
<li>即便计算机具备多核的 CPU，Python线程也无法真正实现并行，因为它们会受全局解释器锁（GIL）牵制。</li>
<li>虽然Python的多线程机制受GIL影响，但还是非常有用的，因为我们很容易就能通过多线程模拟同时执行多项任务的效果。</li>
<li>多条Python线程可以并行地执行多个系统调用，这样就能让程序在执行阻塞式的I&#x2F;O任务时，继续做其他运算。</li>
</ul>
<h2 id="第54条-利用Lock防止多个线程争用同一份数据"><a href="#第54条-利用Lock防止多个线程争用同一份数据" class="headerlink" title="第54条  利用Lock防止多个线程争用同一份数据"></a>第54条  利用Lock防止多个线程争用同一份数据</h2><p>程序在执行完当前这条字节码指令之后，可能会被Python系统切换走，等它稍后切换回来继续执行下一条字节码指令时，当前的数据或许已经与实际值脱节了，因为中途切换进来的其他线程可能更新过这个值。所以，多个线程同时访问同一个对象是很危险的。每条线程在操作这份数据时，都有可能遭到其他线程打扰，因此数据之中的固定关系或许已经被别的线程破坏了，这会令程序陷入混乱状态。为了避免数据争用，可以使用threading中的Lock类，它相当于互斥锁（mutex）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span>(<span class="params">self, offset</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">how_many, counter</span>):</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span>**<span class="number">5</span></span><br><span class="line">counter = Counter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(counter.count)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">500000</span></span><br></pre></td></tr></table></figure>

<h2 id="第55条-用Queue来协调各线程之间的工作进度"><a href="#第55条-用Queue来协调各线程之间的工作进度" class="headerlink" title="第55条  用Queue来协调各线程之间的工作进度"></a>第55条  用Queue来协调各线程之间的工作进度</h2><ul>
<li>管道非常适合用来安排多阶段的任务，让我们能够把每一阶段都交给各自的线程去执行，这尤其适合用在I&#x2F;O密集型的程序里面。</li>
<li>构造这种并发的管道时，有很多问题需要注意，例如怎样防止线程频繁地查询队列状态，怎样通知线程尽快结束操作，以及怎样防止管道出现拥堵等。</li>
<li>我们可以利用Queue类所具有的功能来构造健壮的管道系统，因为这个类提供了阻塞式的入队（put）与出队（get）操作，而且可以限定缓冲区的大小，还能够通过task-done 与join来确保所有元素都已处理完毕。</li>
</ul>
<h2 id="第56条-学会判断什么场合必须做并发"><a href="#第56条-学会判断什么场合必须做并发" class="headerlink" title="第56条  学会判断什么场合必须做并发"></a>第56条  学会判断什么场合必须做并发</h2><p>案例：康威生命游戏，经典的<strong>有限状态自动机</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">ALIVE = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">EMPTY = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, height, width</span>):</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.width = width</span><br><span class="line">        self.rows = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.height):</span><br><span class="line">            self.rows.append([EMPTY] * self.width)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, y, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.rows[y % self.height][x % self.width]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, y, x, state</span>):</span></span><br><span class="line">        self.rows[y % self.height][x % self.width] = state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        output = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> self.rows:</span><br><span class="line">            <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">                output += cell</span><br><span class="line">            output += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_neighbors</span>(<span class="params">y, x, get</span>):</span></span><br><span class="line">    n_ = get(y - <span class="number">1</span>, x + <span class="number">0</span>)  <span class="comment"># North</span></span><br><span class="line">    ne = get(y - <span class="number">1</span>, x + <span class="number">1</span>)  <span class="comment"># Northeast</span></span><br><span class="line">    e_ = get(y + <span class="number">0</span>, x + <span class="number">1</span>)  <span class="comment"># East</span></span><br><span class="line">    se = get(y + <span class="number">1</span>, x + <span class="number">1</span>)  <span class="comment"># Southeast</span></span><br><span class="line">    s_ = get(y + <span class="number">1</span>, x + <span class="number">0</span>)  <span class="comment"># South</span></span><br><span class="line">    sw = get(y + <span class="number">1</span>, x - <span class="number">1</span>)  <span class="comment"># Southwest</span></span><br><span class="line">    w_ = get(y + <span class="number">0</span>, x - <span class="number">1</span>)  <span class="comment"># West</span></span><br><span class="line">    nw = get(y - <span class="number">1</span>, x - <span class="number">1</span>)  <span class="comment"># Northwest</span></span><br><span class="line">    neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> neighbor_states:</span><br><span class="line">        <span class="keyword">if</span> state == ALIVE:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game_logic</span>(<span class="params">state, neighbors</span>):</span></span><br><span class="line">    <span class="keyword">if</span> state == ALIVE:</span><br><span class="line">        <span class="keyword">if</span> neighbors &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> EMPTY     <span class="comment"># Die: Too few</span></span><br><span class="line">        <span class="keyword">elif</span> neighbors &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> EMPTY     <span class="comment"># Die: Too many</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> neighbors == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> ALIVE     <span class="comment"># Regenerate</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_cell</span>(<span class="params">y, x, get, <span class="built_in">set</span></span>):</span></span><br><span class="line">    state = get(y, x)</span><br><span class="line">    neighbors = count_neighbors(y, x, get)</span><br><span class="line">    next_state = game_logic(state, neighbors)</span><br><span class="line">    <span class="built_in">set</span>(y, x, next_state)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate</span>(<span class="params">grid</span>):</span></span><br><span class="line">    next_grid = Grid(grid.height, grid.width)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(grid.height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(grid.width):</span><br><span class="line">            step_cell(y, x, grid.get, next_grid.<span class="built_in">set</span>)</span><br><span class="line">    <span class="keyword">return</span> next_grid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多人在线的话，加入IO操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game_logic</span>(<span class="params">state, neighbors</span>):</span></span><br><span class="line">    <span class="comment"># Do some blocking input/output in here:</span></span><br><span class="line">    data = my_socket.recv(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>game_logic这种写法的问题在于，它会拖慢整个程序的速度。如果game_logic函数每次执行的I&#x2F;O操作需要100毫秒才能完成（与国外的玩家通信一个来回，确实有可能需要这么长时间），那么把整张网格向前推进一代最少需要45秒，因为 simulate函数在推进网格时，是一个一个单元格来计算的。它需要把这45个单元格按顺序计算一遍。这对于网络游戏来说，实在太慢，让人没耐心玩下去。另外，这个方案也无法扩展，假如单元格的数量增加到一万，那么计算新一代网格所花的总时间就会超过15分钟。<br>若想降低延迟时间，应该平行地执行这些I&#x2F;O操作，这样的话，无论网格有多大，都只需要100毫秒左右就能推进到下一代。针对每个工作单元开辟一条执行路径，这种模式叫作扇出（fan-out），对于本例来说，工作单元指的是网格中的单元格。然后，要等待这些并发的工作单元全部完工，才能执行下一个环节，这种模式叫作扇入（fan-in)，对于本例来说，下一个环节指的是让整张网格进入新的一代。<br>Python提供了许多内置的工具，可以实现fan-out与fan-in模式，这些工具各有利弊。我们要了解每种方案的优点和缺点，这样才能用最合适的工具来应对具体的需求。下面几条会继续以生命游戏为例，详细讲解这些工具（参见第57条、第58条、第59条与第60条）。</p>
<ul>
<li>程序范围变大、需求变复杂之后,经常要用多条路径平行地处理任务。</li>
<li>fan-out与fan-in是最常见的两种并发协调（concurrency coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。</li>
<li>Python提供了很多种实现fan-out与fan-in的方案。</li>
</ul>
<h2 id="第57条-不要在每次fan-out时都新建一批Thread实例"><a href="#第57条-不要在每次fan-out时都新建一批Thread实例" class="headerlink" title="第57条  不要在每次fan-out时都新建一批Thread实例"></a>第57条  不要在每次fan-out时都新建一批Thread实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingGrid</span>(<span class="params">Grid</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, height, width</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(height, width)</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().__str__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, y, x</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().get(y, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, y, x, state</span>):</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>().<span class="built_in">set</span>(y, x, state)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_threaded</span>(<span class="params">grid</span>):</span></span><br><span class="line">    next_grid = LockingGrid(grid.height, grid.width)</span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(grid.height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(grid.width):</span><br><span class="line">            args = (y, x, grid.get, next_grid.<span class="built_in">set</span>)</span><br><span class="line">            thread = Thread(target=step_cell, args=args)</span><br><span class="line">            thread.start()  <span class="comment"># Fan out</span></span><br><span class="line">            threads.append(thread)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()       <span class="comment"># Fan in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next_grid</span><br></pre></td></tr></table></figure>

<p>如果需要一大批执行路径分头去执行某项任务，而且还要频繁地启动并停止这批执行路径，那么每次都需手工新建一批线程，这肯定不是个好办法。Python提供了其他几种更合适的方案（参见第58条、第59条与第60条）。</p>
<ul>
<li>每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</li>
<li>线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</li>
</ul>
<h2 id="第58条-学会正确地重构代码，以便用Queue做并发"><a href="#第58条-学会正确地重构代码，以便用Queue做并发" class="headerlink" title="第58条  学会正确地重构代码，以便用Queue做并发"></a>第58条  学会正确地重构代码，以便用Queue做并发</h2><ul>
<li>把队列（Queue）与一定数量的工作线程搭配起来，可以高效地实现fan-out（分派）与fan-in（归集）。</li>
<li>为了改用队列方案来处理IO，我们重构了许多代码，如果管道要分成好几个环节，那么要修改的地方会更多。</li>
<li>利用队列并行地处理IO任务，其处理IO任务量有限，我们可以考虑用Python内置的某些功能与模块打造更好的方案。</li>
</ul>
<h2 id="第59条-如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现"><a href="#第59条-如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现" class="headerlink" title="第59条  如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现"></a>第59条  如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_pool</span>(<span class="params">pool, grid</span>):</span></span><br><span class="line">    next_grid = LockingGrid(grid.height, grid.width)</span><br><span class="line"></span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(grid.height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(grid.width):</span><br><span class="line">            args = (y, x, grid.get, next_grid.<span class="built_in">set</span>)</span><br><span class="line">            future = pool.submit(step_cell, *args)  <span class="comment"># Fan out</span></span><br><span class="line">            futures.append(future)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        future.result()                             <span class="comment"># Fan in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next_grid</span><br><span class="line"></span><br><span class="line">columns = ColumnPrinter()</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        columns.append(<span class="built_in">str</span>(grid))</span><br><span class="line">        grid = simulate_pool(pool, grid)</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor方案仍然有个很大的缺点，就是I&#x2F;O并行能力不高，即便把max_workers设成100，也无法高效地应对那种有一万多个单元格，且每个单元格都要同时做IO的情况。如果你面对的需求，没办法用异步方案解决，而是必须执行完才能往后走（例如文件I&#x2F;O），那么ThreadPoolExecutor是个不错的选择。然而在许多情况下，其实还有并行能力更强的办法可以考虑（参见第60条）。</p>
<ul>
<li>利用 ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I&#x2F;O操作，这种方案省去了每次 fan-out（分派）任务时启动线程的那些开销。</li>
<li>虽然 ThreadPoolExecutor不像直接启动线程的方案那样，需要消耗大量内存，但它的IO并行能力也是有限的。因为它能够使用的最大线程数需要提前通过max_workers参数指定。</li>
</ul>
<h2 id="第60条-用协程实现高并发的I-O"><a href="#第60条-用协程实现高并发的I-O" class="headerlink" title="第60条  用协程实现高并发的I&#x2F;O"></a>第60条  用协程实现高并发的I&#x2F;O</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">game_logic</span>(<span class="params">state, neighbors</span>):</span></span><br><span class="line">    <span class="comment"># Do some input/output in here:</span></span><br><span class="line">    data = <span class="keyword">await</span> my_socket.read(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">game_logic</span>(<span class="params">state, neighbors</span>):</span></span><br><span class="line">    <span class="keyword">if</span> state == ALIVE:</span><br><span class="line">        <span class="keyword">if</span> neighbors &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> EMPTY     <span class="comment"># Die: Too few</span></span><br><span class="line">        <span class="keyword">elif</span> neighbors &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> EMPTY     <span class="comment"># Die: Too many</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> neighbors == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> ALIVE     <span class="comment"># Regenerate</span></span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">step_cell</span>(<span class="params">y, x, get, <span class="built_in">set</span></span>):</span></span><br><span class="line">    state = get(y, x)</span><br><span class="line">    neighbors = count_neighbors(y, x, get)</span><br><span class="line">    next_state = <span class="keyword">await</span> game_logic(state, neighbors)</span><br><span class="line">    <span class="built_in">set</span>(y, x, next_state)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">simulate</span>(<span class="params">grid</span>):</span></span><br><span class="line">    next_grid = Grid(grid.height, grid.width)</span><br><span class="line"></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(grid.height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(grid.width):</span><br><span class="line">            task = step_cell(</span><br><span class="line">                y, x, grid.get, next_grid.<span class="built_in">set</span>)      <span class="comment"># Fan out</span></span><br><span class="line">            tasks.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)                    <span class="comment"># Fan in</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next_grid</span><br><span class="line"></span><br><span class="line">columns = ColumnPrinter()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    columns.append(<span class="built_in">str</span>(grid))</span><br><span class="line">    grid = asyncio.run(simulate(grid))   <span class="comment"># Run the event loop</span></span><br></pre></td></tr></table></figure>

<p>协程的优点是，能够把那些与外部环境交互的代码（例如I&#x2F;O调用）与那些实现自身需求的代码（例如事件循环）解耦。这让我们可以把重点放在实现需求所用的逻辑上面，而不用专门花时间去写一些代码来确保这些需求能够并发地执行。</p>
<ul>
<li>协程是采用async 关键字所定义的函数。如果你想执行这个协程,但并不要求立刻就获得执行结果，而是稍后再来获取，那么可以通过 await关键字表达这个意思。</li>
<li>协程能够制造出这样一种效果，让人以为程序里有成千上万个函数都在同一时刻高效地运行着。</li>
<li>协程可以用fan-out（分派）与fan-in（归集）模式实现并行的I&#x2F;O操作，而且能够克服用线程做I&#x2F;O时的缺陷。</li>
</ul>
<h2 id="第61条-学会用asyncio改写那些通过线程实现的I-O"><a href="#第61条-学会用asyncio改写那些通过线程实现的I-O" class="headerlink" title="第61条  学会用asyncio改写那些通过线程实现的I&#x2F;O"></a>第61条  学会用asyncio改写那些通过线程实现的I&#x2F;O</h2><ul>
<li>Python提供了异步版本的for循环、with语句、生成器与推导机制，而且还有很多辅助的库函数，让我们能够顺利地迁移到协程方案。</li>
<li>我们很容易就能利用内置的asyncio模块来改写代码，让程序不要再通过线程执行阻塞式的I&#x2F;O，而是改用协程来执行异步I&#x2F;O。</li>
</ul>
<h2 id="第62条-结合线程与协程，将代码顺利迁移到asyncio"><a href="#第62条-结合线程与协程，将代码顺利迁移到asyncio" class="headerlink" title="第62条  结合线程与协程，将代码顺利迁移到asyncio"></a>第62条  结合线程与协程，将代码顺利迁移到asyncio</h2><ul>
<li>asyncio模块的事件循环提供了一个返回awaitable对象的run_in_executor方法，它能够使协程把同步函数放在线程池执行器（ThreadPoolExecutor）里面执行，让我们可以顺利地将采用线程方案所实现的项目，从上至下地迁移到asyncio方案。</li>
<li>asyncio模块的事件循环还提供了一个可以在同步代码里面调用的run_until_complete方法，用来运行协程并等待其结束。它的功能跟asyncio.run_coroutine_threadsafe类似，只是后者面对的是跨线程的场合，而前者是为同一个线程设计的。这些都有助于将采用线程方案所实现的项目从下至上地迁移到asyncio方案。</li>
</ul>
<h2 id="第63条-让asyncio的时间循环保持畅通，以便进一步提升程序的响应能力"><a href="#第63条-让asyncio的时间循环保持畅通，以便进一步提升程序的响应能力" class="headerlink" title="第63条  让asyncio的时间循环保持畅通，以便进一步提升程序的响应能力"></a>第63条  让asyncio的时间循环保持畅通，以便进一步提升程序的响应能力</h2><ul>
<li>把系统调用（包括阻塞式的I&#x2F;O以及启动线程等操作）放在协程里面执行，会降低程序的响应能力，增加延迟感。</li>
<li>调用asyncio.run时，可以把debug参数设为True，这样能够知道哪些协程降低了事件循环的反应速度。</li>
</ul>
<h2 id="第64条-考虑用concurrent-futures实现真正的并行计算"><a href="#第64条-考虑用concurrent-futures实现真正的并行计算" class="headerlink" title="第64条  考虑用concurrent.futures实现真正的并行计算"></a>第64条  考虑用concurrent.futures实现真正的并行计算</h2><ul>
<li>把需要耗费大量CPU资源的计算任务改用C扩展模块来写，或许能够有效提高程序的运行速度，同时又让程序里的其他代码依然能够利用Python语言自身的特性。但是，这样做的开销比较大，而且容易引入bug。</li>
<li>Python自带的multiprocessing模块提供了许多强大的工具，让我们只需要耗费很少的精力，就可以把某些类型的任务平行地放在多个CPU核心上面处理。</li>
<li>要想发挥出multiprocessing模块的优势，最好是通过concurrent.futures模块及其ProcessPoolExecutor类来编写代码，因为这样做比较简单。</li>
<li>只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。</li>
</ul>
<h1 id="第八章-稳定与性能"><a href="#第八章-稳定与性能" class="headerlink" title="第八章  稳定与性能"></a>第八章  稳定与性能</h1><p>Python有很多内置的特性与模块，可以帮我们加固程序代码，让它应对各种各样的情况。</p>
<h2 id="第65条-合理利用try-except-else-finally结构中的每个代码块"><a href="#第65条-合理利用try-except-else-finally结构中的每个代码块" class="headerlink" title="第65条  合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块"></a>第65条  合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块</h2><h3 id="try-finally形式"><a href="#try-finally形式" class="headerlink" title="try&#x2F;finally形式"></a>try&#x2F;finally形式</h3><p>确保无论某段代码有没有异常，与它配套的清理代码都必须得到执行，同时还想在出现异常的时候，把这个异常向上传播。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_finally_example</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;* Opening file&#x27;</span>)</span><br><span class="line">    handle = <span class="built_in">open</span>(filename, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment"># May raise OSError</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Reading data&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> handle.read()  <span class="comment"># May raise UnicodeDecodeError</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Calling close()&#x27;</span>)</span><br><span class="line">        handle.close()        <span class="comment"># Always runs after try block</span></span><br></pre></td></tr></table></figure>

<h3 id="try-except-else形式"><a href="#try-except-else形式" class="headerlink" title="try&#x2F;except&#x2F;else形式"></a>try&#x2F;except&#x2F;else形式</h3><p>在某段代码发生特定类型异常时，把这种异常向上传播，同时又要在代码没有发生异常的情况下，执行另一端代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_json_key</span>(<span class="params">data, key</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Loading JSON data&#x27;</span>)</span><br><span class="line">        result_dict = json.loads(data)  <span class="comment"># May raise ValueError</span></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Handling ValueError&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Looking up key&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> result_dict[key]         <span class="comment"># May raise KeyError</span></span><br></pre></td></tr></table></figure>

<h3 id="完整的try-except-else-finally形式"><a href="#完整的try-except-else-finally形式" class="headerlink" title="完整的try&#x2F;except&#x2F;else&#x2F;finally形式"></a>完整的try&#x2F;except&#x2F;else&#x2F;finally形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UNDEFINED = <span class="built_in">object</span>()</span><br><span class="line">DIE_IN_ELSE_BLOCK = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_json</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;* Opening file&#x27;</span>)</span><br><span class="line">    handle = <span class="built_in">open</span>(path, <span class="string">&#x27;r+&#x27;</span>)   <span class="comment"># May raise OSError</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Reading data&#x27;</span>)</span><br><span class="line">        data = handle.read()    <span class="comment"># May raise UnicodeDecodeError</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Loading JSON data&#x27;</span>)</span><br><span class="line">        op = json.loads(data)   <span class="comment"># May raise ValueError</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Performing calculation&#x27;</span>)</span><br><span class="line">        value = (</span><br><span class="line">            op[<span class="string">&#x27;numerator&#x27;</span>] /</span><br><span class="line">            op[<span class="string">&#x27;denominator&#x27;</span>])  <span class="comment"># May raise ZeroDivisionError</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Handling ZeroDivisionError&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> UNDEFINED</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Writing calculation&#x27;</span>)</span><br><span class="line">        op[<span class="string">&#x27;result&#x27;</span>] = value</span><br><span class="line">        result = json.dumps(op)</span><br><span class="line">        handle.seek(<span class="number">0</span>)          <span class="comment"># May raise OSError</span></span><br><span class="line">        <span class="keyword">if</span> DIE_IN_ELSE_BLOCK:</span><br><span class="line">            <span class="keyword">import</span> errno</span><br><span class="line">            <span class="keyword">import</span> os</span><br><span class="line">            <span class="keyword">raise</span> OSError(errno.ENOSPC, os.strerror(errno.ENOSPC))</span><br><span class="line">        handle.write(result)    <span class="comment"># May raise OSError</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Calling close()&#x27;</span>)</span><br><span class="line">        handle.close()          <span class="comment"># Always runs</span></span><br></pre></td></tr></table></figure>

<ul>
<li>try&#x2F;finally形式的复合语句可以确保，无论try块是否抛出异常，finally块都会得到运行。</li>
<li>如果某段代码应该在前一段代码顺利执行之后加以运行，那么可以把它放到else块里面，而不要把这两段代码全都写在try块之中。这样可以让try块更加专注，同时也能够跟except块形成明确对照：except块写的是try块没有顺利执行时所要运行的代码。</li>
<li>如果你要在某段代码顺利执行之后多做一些处理，然后再清理资源，那么通常可以考虑把这三段代码分别放在try、else与finally块里。</li>
</ul>
<h2 id="第66条-考虑用contextlib与with语句来改写可复用的try-finally代码"><a href="#第66条-考虑用contextlib与with语句来改写可复用的try-finally代码" class="headerlink" title="第66条  考虑用contextlib与with语句来改写可复用的try&#x2F;finally代码"></a>第66条  考虑用contextlib与with语句来改写可复用的try&#x2F;finally代码</h2><p>with语句可以用来强调某段代码需要在特殊情境之中执行。与相应的try&#x2F;finally结构是一个意思，但写起来比较方便。</p>
<p>如果想让其他对象与函数也可以这样用在with里面，可以用内置的contextlib模块实现。这个模块提供了contextmanager修饰器，比实现__enter__与__exit__特殊方法的标准做法简单。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span>():</span></span><br><span class="line">    logging.debug(<span class="string">&#x27;Some debug data&#x27;</span>)</span><br><span class="line">    logging.error(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    logging.debug(<span class="string">&#x27;More debug data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_logging</span>(<span class="params">level</span>):</span></span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    old_level = logger.getEffectiveLevel()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        logger.setLevel(old_level)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> debug_logging(logging.DEBUG):</span><br><span class="line">    my_function()</span><br></pre></td></tr></table></figure>

<h3 id="带目标的with语句"><a href="#带目标的with语句" class="headerlink" title="带目标的with语句"></a>带目标的with语句</h3><p>with … as …，可以把情境管理器所返回的对象赋给as右侧的局部变量。例如打开文件。</p>
<p>如果想让自己的函数也支持这个结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_level</span>(<span class="params">level, name</span>):</span></span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line">    old_level = logger.getEffectiveLevel()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> logger</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        logger.setLevel(old_level)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> log_level(logging.DEBUG, <span class="string">&#x27;my_log&#x27;</span>) <span class="keyword">as</span> logger:</span><br><span class="line">    logger.debug(<span class="string">&#x27;debug message&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第67条-用datetime模块处理本地时间，不要用time模块"><a href="#第67条-用datetime模块处理本地时间，不要用time模块" class="headerlink" title="第67条  用datetime模块处理本地时间，不要用time模块"></a>第67条  用datetime模块处理本地时间，不要用time模块</h2><p>协调世界时（UTC）是标准的时间表示方法，不依赖于时区。但UTC不太直观，很多程序中要涉及到时区转换。</p>
<h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">now = <span class="number">1552774475</span></span><br><span class="line">local_tuple = time.localtime(now)</span><br><span class="line">time_format = <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line">time_str = time.strftime(time_format, local_tuple)</span><br><span class="line"><span class="built_in">print</span>(time_str)</span><br><span class="line"></span><br><span class="line">time_tuple = time.strptime(time_str, time_format)</span><br><span class="line">utc_now = time.mktime(time_tuple)</span><br><span class="line"><span class="built_in">print</span>(utc_now)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This example doesn&#x27;t work on Windows&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parse_format = <span class="string">&#x27;%Y-%m-%d %H:%M:%S %Z&#x27;</span></span><br><span class="line">    depart_sfo = <span class="string">&#x27;2019-03-16 15:45:16 PDT&#x27;</span></span><br><span class="line">    time_tuple = time.strptime(depart_sfo, parse_format)</span><br><span class="line">    time_str = time.strftime(time_format, time_tuple)</span><br><span class="line">    <span class="built_in">print</span>(time_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    arrival_nyc = <span class="string">&#x27;2019-03-16 23:33:24 EDT&#x27;</span></span><br><span class="line">    time_tuple = time.strptime(arrival_nyc, time_format)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    logging.exception(<span class="string">&#x27;Expected&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>该模块的功能依赖具体的平台运作，显得不太可靠。time模块没办法稳定地处理多个时区。</p>
<h3 id="datatime模块"><a href="#datatime模块" class="headerlink" title="datatime模块"></a>datatime模块</h3><p>UTC与本地时间转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone</span><br><span class="line"></span><br><span class="line">now = datetime(<span class="number">2019</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">35</span>)</span><br><span class="line">now_utc = now.replace(tzinfo=timezone.utc)</span><br><span class="line">now_local = now_utc.astimezone()</span><br><span class="line"><span class="built_in">print</span>(now_local)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">2019</span>-03-<span class="number">17</span> 06:<span class="number">14</span>:<span class="number">35</span>+08:<span class="number">00</span></span><br><span class="line"></span><br><span class="line">time_str = <span class="string">&#x27;2019-03-16 15:14:35&#x27;</span></span><br><span class="line">now = datetime.strptime(time_str, time_format)</span><br><span class="line">time_tuple = now.timetuple()</span><br><span class="line">utc_now = time.mktime(time_tuple)</span><br><span class="line"><span class="built_in">print</span>(utc_now)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1552720475.0</span></span><br></pre></td></tr></table></figure>

<p>datatime里有相应的机制，可以把一个时区的本地时间可靠地转化成另一个时区的本地时间（通过tzinfo类与相关的方法）。pytz模块用以补充缺失的时区信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">arrival_nyc = <span class="string">&#x27;2019-03-16 23:33:24&#x27;</span></span><br><span class="line">nyc_dt_naive = datetime.strptime(arrival_nyc, time_format)</span><br><span class="line">eastern = pytz.timezone(<span class="string">&#x27;US/Eastern&#x27;</span>)</span><br><span class="line">nyc_dt = eastern.localize(nyc_dt_naive)</span><br><span class="line">utc_dt = pytz.utc.normalize(nyc_dt.astimezone(pytz.utc))</span><br><span class="line"><span class="built_in">print</span>(utc_dt)</span><br><span class="line"></span><br><span class="line">pacific = pytz.timezone(<span class="string">&#x27;US/Pacific&#x27;</span>)</span><br><span class="line">sf_dt = pacific.normalize(utc_dt.astimezone(pacific))</span><br><span class="line"><span class="built_in">print</span>(sf_dt)</span><br><span class="line"></span><br><span class="line">nepal = pytz.timezone(<span class="string">&#x27;Asia/Katmandu&#x27;</span>)</span><br><span class="line">nepal_dt = nepal.normalize(utc_dt.astimezone(nepal))</span><br><span class="line"><span class="built_in">print</span>(nepal_dt)</span><br></pre></td></tr></table></figure>

<p>在操纵时间数据的过程中，总是应该使用UTC时间，只有到最后一步才需要转化成本地时间显示出来。</p>
<h2 id="第68条-用copyreg实现可靠的pickle操作"><a href="#第68条-用copyreg实现可靠的pickle操作" class="headerlink" title="第68条  用copyreg实现可靠的pickle操作"></a>第68条  用copyreg实现可靠的pickle操作</h2><p>Python内置的pickle模块可以把对象序列化为字节流，也可以把字节流反序列化成对象。经过pickle处理的字节流，只应该在彼此信任的双方之间传输，pickle没有考虑过安全问题。</p>
<p>pickle 模块的主要用途仅仅是让我们能够把对象轻松地序列化成二进制数据。如果想直接使用这个模块来实现比这更为复杂的需求，那么可能就会看到奇怪的结果。</p>
<p>解决这样的问题，也非常简单，即可以用内置的 copyreg 模块解决。这个模块允许我们向系统注册相关的函数，把 Python 对象的序列化与反序列化操作交给那些函数去处理这样的话，pickle 模块就运作得更加稳定了。</p>
<h3 id="给新属性设定默认值"><a href="#给新属性设定默认值" class="headerlink" title="给新属性设定默认值"></a>给新属性设定默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="number">0</span>, lives=<span class="number">4</span>, points=<span class="number">0</span></span>):</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.lives = lives</span><br><span class="line">        self.points = points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pickle_game_state</span>(<span class="params">game_state</span>):</span></span><br><span class="line">    kwargs = game_state.__dict__</span><br><span class="line">    <span class="keyword">return</span> unpickle_game_state, (kwargs,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle_game_state</span>(<span class="params">kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> GameState(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copyreg</span><br><span class="line"></span><br><span class="line">copyreg.pickle(GameState, pickle_game_state)</span><br><span class="line"></span><br><span class="line">state = GameState()</span><br><span class="line">state.points += <span class="number">1000</span></span><br><span class="line">serialized = pickle.dumps(state)</span><br><span class="line">state_after = pickle.loads(serialized)</span><br></pre></td></tr></table></figure>

<h3 id="用版本号标注同一个类的不同定义"><a href="#用版本号标注同一个类的不同定义" class="headerlink" title="用版本号标注同一个类的不同定义"></a>用版本号标注同一个类的不同定义</h3><p>有时候我们要做的改动是无法向后兼容的。这个问题可以通过添加版本号解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameState</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="number">0</span>, points=<span class="number">0</span>, magic=<span class="number">5</span></span>):</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.points = points</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pickle.loads(serialized)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    logging.exception(<span class="string">&#x27;Expected&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pickle_game_state</span>(<span class="params">game_state</span>):</span></span><br><span class="line">    kwargs = game_state.__dict__</span><br><span class="line">    kwargs[<span class="string">&#x27;version&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> unpickle_game_state, (kwargs,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpickle_game_state</span>(<span class="params">kwargs</span>):</span></span><br><span class="line">    version = kwargs.pop(<span class="string">&#x27;version&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> version == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">del</span> kwargs[<span class="string">&#x27;lives&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> GameState(**kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="正确处理类名变化"><a href="#正确处理类名变化" class="headerlink" title="正确处理类名变化"></a>正确处理类名变化</h3><p>这个问题还是可以用 copyreg 解决。如果我们先通过copyreg.pickle注册了负责执行pickle操作的函数，那么系统在把对象转换成序列化数据的时候，就不会将当前的类名作为引入路径写到数据里面了，而是会把那个函数所指定的unpickle函数（即unpickle_game_state）作为引入路径写进去。所以，不管这个类将来改成什么名字，这份数据都可以通过unpickle_game_state 还原，只要那个函数在还原的时候，使用的是正确的类名就行。这样相当于多了一个步骤，以前是直接根据类名还原，现在是先把还原任务交给unpickle函数，然后由那个函数去决定应该还原成哪个类的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BetterGameState</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, level=<span class="number">0</span>, points=<span class="number">0</span>, magic=<span class="number">5</span></span>):</span></span><br><span class="line">        self.level = level</span><br><span class="line">        self.points = points</span><br><span class="line">        self.magic = magic</span><br><span class="line"></span><br><span class="line">copyreg.pickle(BetterGameState, pickle_game_state)</span><br><span class="line"></span><br><span class="line">state = BetterGameState()</span><br><span class="line">serialized = pickle.dumps(state)</span><br></pre></td></tr></table></figure>

<p>只有一个地方要注意，就是负责 unpickle 的 unpickle_game_state 函数所在模块的路径不能变，因为这个函数名已经写到了序列化之后的数据里面，将来反序列化的时候，系统要先找到这个函数，然后才能通过它正确地还原对象。</p>
<h2 id="第69条-在需要准确计算的场合，用decimal表示相应的数值"><a href="#第69条-在需要准确计算的场合，用decimal表示相应的数值" class="headerlink" title="第69条  在需要准确计算的场合，用decimal表示相应的数值"></a>第69条  在需要准确计算的场合，用decimal表示相应的数值</h2><p>Python整数类型实际上可以表示任意尺寸的整型数据，双精度浮点数类型遵循IEEE 754规范。另外，还提供了标准的复数类型。但是，依然存在问题，例如给国际长途计费：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rate = <span class="number">1.45</span></span><br><span class="line">seconds = <span class="number">3</span>*<span class="number">60</span> + <span class="number">42</span></span><br><span class="line">cost = rate * seconds / <span class="number">60</span></span><br><span class="line"><span class="built_in">print</span>(cost)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">5.364999999999999</span></span><br></pre></td></tr></table></figure>

<p>这个数字比正确答案少了一点点，所以采用浮点数算出的结果可能跟实际结果稍有偏差。另外，如果要四舍五入到分，也会出现5.37与5.36的区别。</p>
<p>这样的计算应该用Python内置的decimal模块的Decimal类来做。这个类默认支持28位小数，且还可以更高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">rate = Decimal(<span class="string">&#x27;1.45&#x27;</span>)</span><br><span class="line">seconds = Decimal(<span class="number">3</span>*<span class="number">60</span> + <span class="number">42</span>)</span><br><span class="line">cost = rate * seconds / Decimal(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(cost)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">5.365</span></span><br></pre></td></tr></table></figure>

<p>Decimal初始值可以用两种办法指定。一是str，二是float或者int，这两种办法在某些小数上会产生不同的效果，对于整数则都相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Decimal(<span class="string">&#x27;1.45&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(Decimal(<span class="number">1.45</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1.45</span></span><br><span class="line"><span class="number">1.4499999999999999555910790149937383830547332763671875</span></span><br></pre></td></tr></table></figure>

<p>Decimal类提供了quantize函数，可以根据指定的舍入方式把数值调整到某一位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> ROUND_UP</span><br><span class="line"></span><br><span class="line">rounded = cost.quantize(Decimal(<span class="string">&#x27;0.01&#x27;</span>), rounding=ROUND_UP)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Rounded <span class="subst">&#123;cost&#125;</span> to <span class="subst">&#123;rounded&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rounded = small_cost.quantize(Decimal(<span class="string">&#x27;0.01&#x27;</span>), rounding=ROUND_UP)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Rounded <span class="subst">&#123;small_cost&#125;</span> to <span class="subst">&#123;rounded&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Rounded <span class="number">5.365</span> to <span class="number">5.37</span></span><br><span class="line">Rounded <span class="number">0.004166666666666666666666666667</span> to <span class="number">0.01</span></span><br></pre></td></tr></table></figure>

<p>对于小数点无限的值，依然会有误差。可以用内置的fractions里面的Fraction类来精确表示。</p>
<h2 id="第70条-先分析性能，然后再优化"><a href="#第70条-先分析性能，然后再优化" class="headerlink" title="第70条  先分析性能，然后再优化"></a>第70条  先分析性能，然后再优化</h2><p>Python的动态机制，让我们很难预判程序在运行时的性能。有些操作，看上去似乎比较慢，但实际执行起来却很快（例如操纵字符串，使用生成器等）；还有一些操作，看上去似乎比较快，但实际执行起来却很慢（例如访问属性，调用函数等）。让Python程序速度变慢的原因，有时很难观察出来。</p>
<p>所以，最好不要凭感觉去判断，而是应该先获得具体的测评数据，然后再决定怎么优化。Python内置了profiler模块，可以找到程序里面占总执行时间比例最高的一部分，这样的话，我们就可以专心优化这部分代码，而不用执着于对程序性能影响不大的那些地方（因为你把同样的精力投入到那些地方，产生的提速效果不会太好）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待测评的插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">data</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> data:</span><br><span class="line">        insert_value(result, value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_value</span>(<span class="params">array, value</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, existing <span class="keyword">in</span> <span class="built_in">enumerate</span>(array):</span><br><span class="line">        <span class="keyword">if</span> existing &gt; value:</span><br><span class="line">            array.insert(i, value)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    array.append(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一套随机的测试数据</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">max_size = <span class="number">10</span>**<span class="number">4</span></span><br><span class="line">data = [randint(<span class="number">0</span>, max_size) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_size)]</span><br><span class="line">test = <span class="keyword">lambda</span>: insertion_sort(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建性能分析器</span></span><br><span class="line"><span class="keyword">from</span> cProfile <span class="keyword">import</span> Profile</span><br><span class="line"></span><br><span class="line">profiler = Profile()</span><br><span class="line">profiler.runcall(test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计结果</span></span><br><span class="line"><span class="keyword">from</span> pstats <span class="keyword">import</span> Stats</span><br><span class="line"></span><br><span class="line">stats = Stats(profiler)</span><br><span class="line">stats = Stats(profiler, stream=STDOUT)</span><br><span class="line">stats.strip_dirs()</span><br><span class="line">stats.sort_stats(<span class="string">&#x27;cumulative&#x27;</span>)</span><br><span class="line">stats.print_stats()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">         <span class="number">20003</span> function calls <span class="keyword">in</span> <span class="number">2.690</span> seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: cumulative time</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">2.690</span>    <span class="number">2.690</span> effective python.py:<span class="number">23</span>(&lt;<span class="keyword">lambda</span>&gt;)</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.004</span>    <span class="number">0.004</span>    <span class="number">2.690</span>    <span class="number">2.690</span> effective python.py:<span class="number">2</span>(insertion_sort)</span><br><span class="line">    <span class="number">10000</span>    <span class="number">2.676</span>    <span class="number">0.000</span>    <span class="number">2.686</span>    <span class="number">0.000</span> effective python.py:<span class="number">10</span>(insert_value)</span><br><span class="line">     <span class="number">9996</span>    <span class="number">0.010</span>    <span class="number">0.000</span>    <span class="number">0.010</span>    <span class="number">0.000</span> &#123;method <span class="string">&#x27;insert&#x27;</span> of <span class="string">&#x27;list&#x27;</span> objects&#125;</span><br><span class="line">        <span class="number">1</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> &#123;method <span class="string">&#x27;disable&#x27;</span> of <span class="string">&#x27;_lsprof.Profiler&#x27;</span> objects&#125;</span><br><span class="line">        <span class="number">4</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span>    <span class="number">0.000</span> &#123;method <span class="string">&#x27;append&#x27;</span> of <span class="string">&#x27;list&#x27;</span> objects&#125;</span><br></pre></td></tr></table></figure>

<p>有的时候，在评测完整个程序后，可能会发现大部分时间都耗在了某个常见的工具函数上，单凭默认的统计结果，很难看出性能瓶颈在哪。这时候可以用print_callers方法打印统计结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_utility</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        c += a * b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        my_utility(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second_func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        my_utility(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_program</span>():</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        first_func()</span><br><span class="line">        second_func()</span><br><span class="line"></span><br><span class="line">profiler = Profile()</span><br><span class="line">profiler.runcall(my_program)</span><br><span class="line">stats = Stats(profiler, stream=STDOUT)</span><br><span class="line">stats.strip_dirs()</span><br><span class="line">stats.sort_stats(<span class="string">&#x27;cumulative&#x27;</span>)</span><br><span class="line">stats.print_stats()</span><br><span class="line"></span><br><span class="line">stats = Stats(profiler, stream=STDOUT)</span><br><span class="line">stats.strip_dirs()</span><br><span class="line">stats.sort_stats(<span class="string">&#x27;cumulative&#x27;</span>)</span><br><span class="line">stats.print_callers()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">   Ordered by: cumulative time</span><br><span class="line"></span><br><span class="line">Function                                          was called by...</span><br><span class="line">                                                      ncalls  tottime  cumtime</span><br><span class="line">effective python.py:<span class="number">49</span>(my_program)                &lt;- </span><br><span class="line">effective python.py:<span class="number">41</span>(first_func)                &lt;-      <span class="number">20</span>    <span class="number">0.005</span>    <span class="number">0.168</span>  effective python.py:<span class="number">49</span>(my_program)</span><br><span class="line">effective python.py:<span class="number">36</span>(my_utility)                &lt;-   <span class="number">20000</span>    <span class="number">0.163</span>    <span class="number">0.163</span>  effective python.py:<span class="number">41</span>(first_func)</span><br><span class="line">                                                         <span class="number">200</span>    <span class="number">0.001</span>    <span class="number">0.001</span>  effective python.py:<span class="number">45</span>(second_func)</span><br><span class="line">effective python.py:<span class="number">45</span>(second_func)               &lt;-      <span class="number">20</span>    <span class="number">0.000</span>    <span class="number">0.002</span>  effective python.py:<span class="number">49</span>(my_program)</span><br><span class="line">&#123;method <span class="string">&#x27;disable&#x27;</span> of <span class="string">&#x27;_lsprof.Profiler&#x27;</span> objects&#125;  &lt;- </span><br></pre></td></tr></table></figure>

<h2 id="第71条-优先考虑用deque实现生产者—消费者队列"><a href="#第71条-优先考虑用deque实现生产者—消费者队列" class="headerlink" title="第71条  优先考虑用deque实现生产者—消费者队列"></a>第71条  优先考虑用deque实现生产者—消费者队列</h2><p>写程序的时候，经常要用到先进先出的（ first-in，first-out，FIFO）队列，这种队列也叫作生产者—消费者队列（producer-consumer queue）或生产—消费队列。FIFO队列可以把某个函数给出的值收集起来，并交给另一个函数按序处理。一般来说，开发者会用Python内置的list类型来实现FIFO队列。</p>
<p>但是，当列表中的元素变多之后，list的性能就会下降。用pop（0）从队列开头移除元素所花的时间竟然跟队列长度呈反比关系。为什么会这样呢？这是因为，用pop（0）删掉开头元素时，需要把后面的每个元素都向前移动一个位置，这相当于把整份列表的内容都改掉。消费函数需要针对list中的所有元素（共有len (queue）个）都做一次pop（0），而每次pop(0)又需要执行大约Ien（queue）次移动,所以总的操作次数就是len（queue）*len（queue）次。这种算法不能够大规模运用。</p>
<p>Python内置的collections模块里面有个 deque类，可以解决这个问题。这个类所实现的是双向队列（ double—ended queue)，从头部执行插入或尾部执行删除操作，都只需要固定的时间，所以它很适合充当 FIFO 队列。Python内置的集合模块里面有个deque类，可以解天这个问题。这个类所实现的是双向队列(双端队列)，从头部执行插人或尾部执行删除操作，都只需要固定的时间，所以它很适合充当FIFO队列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume_one_email</span>(<span class="params">queue</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> queue:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    email = queue.popleft()  <span class="comment"># Consumer</span></span><br><span class="line">    <span class="comment"># Process the email message</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Consumed email: <span class="subst">&#123;email.message&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_end_func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_end_func = make_test_end()</span><br><span class="line">EMAIL_IT = get_emails()</span><br><span class="line">loop(collections.deque(), my_end_func)</span><br></pre></td></tr></table></figure>

<h2 id="第72条-考虑用bisect搜索已排序队列"><a href="#第72条-考虑用bisect搜索已排序队列" class="headerlink" title="第72条  考虑用bisect搜索已排序队列"></a>第72条  考虑用bisect搜索已排序队列</h2><p>Python内置的bisect模块可以更好地搜索有序列表。其中的bisect_left函数，能够迅速地对任何一个有序的序列执行二分搜索。如果序列中有这个值，那么它返回的就是跟这个值相等的头一个元素所在的位置；如果没有，那么它返回的是插入位置，也就是说，把待查的值插到这个位置可以让序列继续保持有序。</p>
<p>bisect模块的二分搜索算法，在复杂度上面是对数级别的。这意味着，线性搜索算法（list.index方法）在包含20个元素的列表中查询目标值所花的时间，已经够这个算法搜索长度为一百万个元素的列表了（math. log2(10**6)大约是19.93）。它要比线性搜索快得多！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>**<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">index = bisect_left(data, <span class="number">91234</span>)</span><br><span class="line"><span class="keyword">assert</span> index == <span class="number">91234</span></span><br><span class="line"></span><br><span class="line">index = bisect_left(data, <span class="number">91234.56</span>)</span><br><span class="line"><span class="keyword">assert</span> index == <span class="number">91235</span></span><br></pre></td></tr></table></figure>

<p>bisect最好的地方，是它不局限于list类型，而是可以用在任何一种行为类似序列对象上面（怎样让其他对象也表现出跟序列相似的行为，请参见第43条）。bisect模块还提供了其他一些功能，可以实现更为高级的用法。</p>
<h2 id="第73条-学会使用heapq制作优先级队列"><a href="#第73条-学会使用heapq制作优先级队列" class="headerlink" title="第73条  学会使用heapq制作优先级队列"></a>第73条  学会使用heapq制作优先级队列</h2><p>Python中其它队列都是先进先出队列，会按照接收元素的顺序来保存这些元素。但有的时候，我们想要根据元素的重要程度来排序，这种情况应该用优先级队列。</p>
<p>直接用list实现，对于数据量少的情况或许还行，但肯定无法应对大规模数据。好在Python内置的heapq模块可以解决这个问题，因为它能够高效地实现出优先级队列。模块名称里面的heap指的是堆，这是一种数据结构，可以维护列表中的元素，并且只需要对数级别的时间就可以添加新元素或移除其中最小的元素。</p>
<p>下面用heapq模块实现图书馆管理程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_book</span>(<span class="params">queue, book</span>):</span></span><br><span class="line">    heappush(queue, book)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    queue = []</span><br><span class="line">    add_book(queue, Book(<span class="string">&#x27;Little Women&#x27;</span>, <span class="string">&#x27;2019-06-05&#x27;</span>))</span><br><span class="line">    add_book(queue, Book(<span class="string">&#x27;The Time Machine&#x27;</span>, <span class="string">&#x27;2019-05-30&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    logging.exception(<span class="string">&#x27;Expected&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title, due_date</span>):</span></span><br><span class="line">        self.title = title</span><br><span class="line">        self.due_date = due_date</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.due_date &lt; other.due_date</span><br><span class="line"></span><br><span class="line">queue = []</span><br><span class="line">add_book(queue, Book(<span class="string">&#x27;Pride and Prejudice&#x27;</span>, <span class="string">&#x27;2019-06-01&#x27;</span>))</span><br><span class="line">add_book(queue, Book(<span class="string">&#x27;The Time Machine&#x27;</span>, <span class="string">&#x27;2019-05-30&#x27;</span>))</span><br><span class="line">add_book(queue, Book(<span class="string">&#x27;Crime and Punishment&#x27;</span>, <span class="string">&#x27;2019-06-06&#x27;</span>))</span><br><span class="line">add_book(queue, Book(<span class="string">&#x27;Wuthering Heights&#x27;</span>, <span class="string">&#x27;2019-06-12&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>([b.title <span class="keyword">for</span> b <span class="keyword">in</span> queue])</span><br><span class="line"></span><br><span class="line">queue = [</span><br><span class="line">    Book(<span class="string">&#x27;Pride and Prejudice&#x27;</span>, <span class="string">&#x27;2019-06-01&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;The Time Machine&#x27;</span>, <span class="string">&#x27;2019-05-30&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;Crime and Punishment&#x27;</span>, <span class="string">&#x27;2019-06-06&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;Wuthering Heights&#x27;</span>, <span class="string">&#x27;2019-06-12&#x27;</span>),</span><br><span class="line">]</span><br><span class="line">queue.sort()</span><br><span class="line"><span class="built_in">print</span>([b.title <span class="keyword">for</span> b <span class="keyword">in</span> queue])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以不调用sort，而是改用heapq.heapify来构造这个堆。</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heapify</span><br><span class="line"></span><br><span class="line">queue = [</span><br><span class="line">    Book(<span class="string">&#x27;Pride and Prejudice&#x27;</span>, <span class="string">&#x27;2019-06-01&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;The Time Machine&#x27;</span>, <span class="string">&#x27;2019-05-30&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;Crime and Punishment&#x27;</span>, <span class="string">&#x27;2019-06-06&#x27;</span>),</span><br><span class="line">    Book(<span class="string">&#x27;Wuthering Heights&#x27;</span>, <span class="string">&#x27;2019-06-12&#x27;</span>),</span><br><span class="line">]</span><br><span class="line">heapify(queue)</span><br><span class="line"><span class="built_in">print</span>([b.title <span class="keyword">for</span> b <span class="keyword">in</span> queue])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">&#x27;The Time Machine&#x27;</span>, <span class="string">&#x27;Pride and Prejudice&#x27;</span>, <span class="string">&#x27;Crime and Punishment&#x27;</span>, <span class="string">&#x27;Wuthering Heights&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>优先级队列让我们能够按照重要程度来处理元素，而不是必须按照先进先出的顺序处理。</li>
<li>如果直接用相关的列表操作来模拟优先级队列，那么程序的性能会随着队列长度的增大而大幅下降，因为这样做的复杂程度是平方级别，而不是线性级别。</li>
<li>通过Python内置的heapq模块所提供的函数，我们完全可以实现基于堆的优先级队列，从而高效地处理大量数据。</li>
<li>要使用heapq模块，我们必须让元素所在的类型支持自然排序，这可以通过对类套用@functools.total_ordering 修饰器并定义__lt__方法来实现。</li>
</ul>
<h2 id="第74条-考虑用memoryview与bytearray来实现无需拷贝的bytes操作"><a href="#第74条-考虑用memoryview与bytearray来实现无需拷贝的bytes操作" class="headerlink" title="第74条  考虑用memoryview与bytearray来实现无需拷贝的bytes操作"></a>第74条  考虑用memoryview与bytearray来实现无需拷贝的bytes操作</h2><p>对bytes实例做切片需要拷贝底层数据，这会浪费 CPU的时间。这段代码可以通过Python内置的memoryview类型来改进，这个类型让程序能够利用CPython的缓冲协议（buffer protocol）高效地操纵字节数据。这套协议属于底层的C API，允许Python运行时系统与C扩展访问底层的数据缓冲，而bytes等实例正是由这种数据缓冲对象所支持的。memoryview最大的优点，是能够在不复制底层数据的前提下，制作出另一个memoryview。下面这段代码，就先把bytes实例封装在memoryview里面，然后再切割，这样不用拷贝底层数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="string">b&#x27;shave and a haircut, two bits&#x27;</span></span><br><span class="line">view = <span class="built_in">memoryview</span>(data)</span><br><span class="line">chunk = view[<span class="number">12</span>:<span class="number">19</span>]</span><br><span class="line"><span class="built_in">print</span>(chunk)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Size:           &#x27;</span>, chunk.nbytes)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Data in view:   &#x27;</span>, chunk.tobytes())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Underlying data:&#x27;</span>, chunk.obj)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&lt;memory at <span class="number">0x0000018512167B80</span>&gt;</span><br><span class="line">Size:            <span class="number">7</span></span><br><span class="line">Data <span class="keyword">in</span> view:    <span class="string">b&#x27;haircut&#x27;</span></span><br><span class="line">Underlying data: <span class="string">b&#x27;shave and a haircut, two bits&#x27;</span></span><br></pre></td></tr></table></figure>

<p>由于它执行的是零拷贝操作，因此对需要高速处理大量内存数据的代码来说用处很大。</p>
<p>而bytearray则相当于可修改的bytes，它允许我们修改任意位置上面的内容。bytearray 采用整数表示其中的内容，而不像bytes那样，采用b开头的字面值。</p>
<p>bytearray与bytes一样，也可以用memoryview封装，在这种memoryview上面切割出来的对象，其内容可以用另一份数据替换，这样做，替换的实际上是 memoryview背后那个底层缓冲区里面的相应部分。这使得我们可以通过memoryview来修改它所封装的bytearray，而不像刚才那样,必须先将bytes拆散，然后再拼起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my_array = <span class="built_in">bytearray</span>(<span class="string">b&#x27;hello&#x27;</span>)</span><br><span class="line">my_array[<span class="number">0</span>] = <span class="number">0x79</span></span><br><span class="line"><span class="built_in">print</span>(my_array)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;yello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">my_array = <span class="built_in">bytearray</span>(<span class="string">b&#x27;row, row, row your boat&#x27;</span>)</span><br><span class="line">my_view = <span class="built_in">memoryview</span>(my_array)</span><br><span class="line">write_view = my_view[<span class="number">3</span>:<span class="number">13</span>]</span><br><span class="line">write_view[:] = <span class="string">b&#x27;-10 bytes-&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(my_array)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;row-10 bytes- your boat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Python里面很多库之中的方法，例如 socket.recv_into 与 RawIOBase. readinto，都使用缓冲协议来迅速接收或读取数据。这种方法的好处是不用分配内存，也不用给原数据制作复本，它们会把收到的内容直接写入现有的缓冲区。</p>
<h1 id="第九章-测试与调试"><a href="#第九章-测试与调试" class="headerlink" title="第九章  测试与调试"></a>第九章  测试与调试</h1><h2 id="第75条-通过repr字符串输出调试信息"><a href="#第75条-通过repr字符串输出调试信息" class="headerlink" title="第75条  通过repr字符串输出调试信息"></a>第75条  通过repr字符串输出调试信息</h2><ul>
<li>把内置类型的值传给print，会打印出便于认读的那种字符串，但是其中不会包含类型信息。</li>
<li>把内置类型的值传给repr，会得到一个能够表示该值的可打印字符串，将这个reepr字符串传给内置的eval函数能够得到原值。</li>
<li>在格式化字符串里用%s处理相关的值，就跟把这个值传给str函数一样，都能得到一个便于认读的那种字符串。如果用%r来处理，那么得到的就是repr字符串。在f-string中，也可以用值来取代其中有待替换的那一部分，并产生便于认读的那种字符串，但如果待替换的部分加了!r后缀，那么替换出来的就是repr字符串。</li>
<li>给类定义__repr__特殊方法，可以让print函数把该类实例的可打印表现展现出来，在实现这个方法时，还可以提供更为详尽的调试信息。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int_value = <span class="number">5</span></span><br><span class="line">str_value = <span class="string">&#x27;5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;int_value&#125;</span> == <span class="subst">&#123;str_value&#125;</span> ?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">5</span> == <span class="number">5</span> ?</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="string">&#x27;5&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="第76条-在TestCase子类里验证相关行为"><a href="#第76条-在TestCase子类里验证相关行为" class="headerlink" title="第76条  在TestCase子类里验证相关行为"></a>第76条  在TestCase子类里验证相关行为</h2><p>在Python里编写测试最经典办法是使用内置的unittest模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilsTestCase</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_bytes</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="string">&#x27;hello&#x27;</span>, to_str(<span class="string">b&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_to_str_str</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="string">&#x27;hello&#x27;</span>, to_str(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_failing</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="string">&#x27;incorrect&#x27;</span>, to_str(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.020</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello != incorrect</span><br><span class="line"></span><br><span class="line">预期:incorrect</span><br><span class="line">实际:hello</span><br><span class="line">&lt;点击以查看差异&gt;</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> test_failing</span><br><span class="line">    self.assertEqual(<span class="string">&#x27;incorrect&#x27;</span>, to_str(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">AssertionError: <span class="string">&#x27;incorrect&#x27;</span> != <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">- incorrect</span><br><span class="line">+ hello</span><br></pre></td></tr></table></figure>

<p>测试用例需要安排到TestCase的子类中。在这样的子类中，每个以 test 开头的方法都表示一项测试用例。如果test方法在运行过程中没有抛出任何异常（assert语句所触发的AssertionError也算异常），那么这项测试用例就是成功的，否则就是失败。其中一项测试用例失败，并不影响系统继续执行TestCase子类里的其他 test方法，所以我们最后能够看到总的结果，知道其中有多少项测试用例成功，多少项失败，而不是只要遇到测试用例失败，就立刻停止整套测试。</p>
<p>在修改了软件产品中的某个方法之后，我们可能想把针对该方法而写的测试用例迅速执行一遍，看自己改得对不对。在这种情况下，可以把TestCase子类的名称与test方法的名字直接写在原有的命令右边。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 utils_test.py UtilsTestCase.test_to_str_bytes</span><br></pre></td></tr></table></figure>

<p>TestCase类里提供了一些辅助方法，可以在测试用例里做断言：assertEqual可以确认二者是否相等；assertTrue确认Boolean表达式是否为True；assertRaises验证结构的主体部分是否会抛出应有的异常。</p>
<p>如果测试用例需要使用比较复杂的逻辑，那么可以把这些逻辑定义成辅助方法放到TestCase子类里。但是必须注意，<strong>这种方法的名称不能以test开头，否则系统就会把它们当成测试用例来执行</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_squares</span>(<span class="params">values</span>):</span></span><br><span class="line">    cumulative = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        cumulative += value ** <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> cumulative</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelperTestCase</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_complex_case</span>(<span class="params">self, values, expected</span>):</span></span><br><span class="line">        expect_it = <span class="built_in">iter</span>(expected)</span><br><span class="line">        found_it = <span class="built_in">iter</span>(sum_squares(values))</span><br><span class="line">        test_it = <span class="built_in">zip</span>(expect_it, found_it)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, (expect, found) <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_it):</span><br><span class="line">            self.assertEqual(</span><br><span class="line">                expect,</span><br><span class="line">                found,</span><br><span class="line">                <span class="string">f&#x27;Index <span class="subst">&#123;i&#125;</span> is wrong&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Verify both generators are exhausted</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">next</span>(expect_it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.fail(<span class="string">&#x27;Expected longer than found&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">next</span>(found_it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.fail(<span class="string">&#x27;Found longer than expected&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_wrong_lengths</span>(<span class="params">self</span>):</span></span><br><span class="line">        values = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>]</span><br><span class="line">        expected = [</span><br><span class="line">            <span class="number">1.1</span>**<span class="number">2</span>,</span><br><span class="line">        ]</span><br><span class="line">        self.verify_complex_case(values, expected)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_wrong_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        values = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>]</span><br><span class="line">        expected = [</span><br><span class="line">            <span class="number">1.1</span>**<span class="number">2</span>,</span><br><span class="line">            <span class="number">1.1</span>**<span class="number">2</span> + <span class="number">2.2</span>**<span class="number">2</span>,</span><br><span class="line">            <span class="number">1.1</span>**<span class="number">2</span> + <span class="number">2.2</span>**<span class="number">2</span> + <span class="number">3.3</span>**<span class="number">2</span> + <span class="number">4.4</span>**<span class="number">2</span>,</span><br><span class="line">        ]</span><br><span class="line">        self.verify_complex_case(values, expected)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Failure</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">41</span>, <span class="keyword">in</span> test_wrong_lengths</span><br><span class="line">    self.verify_complex_case(values, expected)</span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">34</span>, <span class="keyword">in</span> verify_complex_case</span><br><span class="line">    self.fail(<span class="string">&#x27;Found longer than expected&#x27;</span>)</span><br><span class="line">AssertionError: Found longer than expected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">0.009</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Index <span class="number">2</span> <span class="keyword">is</span> wrong</span><br><span class="line"><span class="number">16.939999999999998</span> != <span class="number">36.3</span></span><br><span class="line"></span><br><span class="line">预期:<span class="number">36.3</span></span><br><span class="line">实际:<span class="number">16.939999999999998</span></span><br><span class="line">&lt;点击以查看差异&gt;</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">50</span>, <span class="keyword">in</span> test_wrong_results</span><br><span class="line">    self.verify_complex_case(values, expected)</span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> verify_complex_case</span><br><span class="line">    self.assertEqual(</span><br><span class="line">AssertionError: <span class="number">36.3</span> != <span class="number">16.939999999999998</span> : Index <span class="number">2</span> <span class="keyword">is</span> wrong</span><br></pre></td></tr></table></figure>

<p>可以把相关的测试归为一组，并针对每组测试定义相应的TestCase子类。如果某个函数有许多种边界情况要测，那么笔者喜欢专门针对这个函数定义一个TestCase子类，而对那些比较简单的函数，笔者则喜欢把同一个模块里的这些函数全都放在同一个TestCase子类中。另外，笔者喜欢针对每个基本的类单独创建对应的TestCase子类，以测试该类及类中的各个方法。TestCase类还提供了subTest辅助方法，可以让我们把相似的用例全都写在同一个test方法中，让它们成为这个用例中的子用例，这样的话，每个子用例所共用的那部分代码与逻辑只需要写一次就行。对由数据所驱动的测试来说，这个辅助方法尤其有用，因为其中一条数据（也就是一项子用例）测试失败，并不影响后面的数据（也就是后面的那些子用例）继续接受测试（这与TestCase子类里的那些test方法一样， 即便其中有某个test方法测试失败，其他的test方法也还是可以继续接受测试）。下面定义一套数据，演示如何通过subTest方法做数据驱动测试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> to_str</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataDrivenTestCase</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_good</span>(<span class="params">self</span>):</span></span><br><span class="line">        good_cases = [</span><br><span class="line">            (<span class="string">b&#x27;my bytes&#x27;</span>, <span class="string">&#x27;my bytes&#x27;</span>),</span><br><span class="line">            (<span class="string">&#x27;no error&#x27;</span>, <span class="string">b&#x27;no error&#x27;</span>),  <span class="comment"># This one will fail</span></span><br><span class="line">            (<span class="string">&#x27;other str&#x27;</span>, <span class="string">&#x27;other str&#x27;</span>),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">for</span> value, expected <span class="keyword">in</span> good_cases:</span><br><span class="line">            <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">                self.assertEqual(expected, to_str(value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_bad</span>(<span class="params">self</span>):</span></span><br><span class="line">        bad_cases = [</span><br><span class="line">            (<span class="built_in">object</span>(), TypeError),</span><br><span class="line">            (<span class="string">b&#x27;\xfa\xfa&#x27;</span>, UnicodeDecodeError),</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">for</span> value, exception <span class="keyword">in</span> bad_cases:</span><br><span class="line">            <span class="keyword">with</span> self.subTest(value):</span><br><span class="line">                <span class="keyword">with</span> self.assertRaises(exception):</span><br><span class="line">                    to_str(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">SubTest failure: Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\...\unittest\case.py&quot;</span>, line <span class="number">57</span>, <span class="keyword">in</span> testPartExecutor</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  File <span class="string">&quot;C:\...\unittest\case.py&quot;</span>, line <span class="number">538</span>, <span class="keyword">in</span> subTest</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  File <span class="string">&quot;XXX.py&quot;</span>, line <span class="number">13</span>, <span class="keyword">in</span> test_good</span><br><span class="line">    self.assertEqual(expected, to_str(value))</span><br><span class="line">  File <span class="string">&quot;C:\...\diff_tools.py&quot;</span>, line <span class="number">33</span>, <span class="keyword">in</span> _patched_equals</span><br><span class="line">    old(self, first, second, msg)</span><br><span class="line">AssertionError: <span class="string">b&#x27;no error&#x27;</span> != <span class="string">&#x27;no error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">One <span class="keyword">or</span> more subtests failed</span><br><span class="line">Failed subtests <span class="built_in">list</span>: [no error]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">0.015</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果项目比较复杂，可以用pytest包。</p>
<h2 id="第77条-把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDown-Module中，以防用例之间相互干扰"><a href="#第77条-把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDown-Module中，以防用例之间相互干扰" class="headerlink" title="第77条  把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDown-Module中，以防用例之间相互干扰"></a>第77条  把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDown-Module中，以防用例之间相互干扰</h2><p>我们可以在TestCase子类中覆写setUp与tearDown方法，并把相应的准备逻辑与清理逻辑写在里面。系统在执行每个test方法之前都会先调用一遍setUp方法，并在执行完test方法之后调用一遍tearDown方法。这可以确保测试用例之间不会互相干扰，这一点，对测试工作至关重要。</p>
<p>例如，我们可以像下面这样把创建临时目录的逻辑放在setUp方法中，使系统在执行在执行test_modify_file用例之前先把存放 ‘data.bin’ 文件所用的临时目录准备好，并在执行完用例之后，通过tearDown方法清空该目录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentTest</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.test_dir = TemporaryDirectory()</span><br><span class="line">        self.test_path = Path(self.test_dir.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.test_dir.cleanup()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_modify_file</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.test_path / <span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>当程序变得复杂后，我们就不能只依赖这种彼此隔绝的单元测试了，而是需要再写一些测试，以验证模块与模块之间能否正确地交互（这可能要用到mock等工具，参见第78条）。这种测试叫集成测试（integration test），它跟前面的单元测试（unit test）不同。这两种测试在Python中很重要，假如不做集成测试，那就没办法确信这些模块能够协同运作。</p>
<p>对于集成测试来说，测试环境的准备与清理工作可能要占用大量计算资源，并持续比较长的时间。例如，可能要先启动数据库进程，并等待该进程把索引加载进来，然后才能开始做集成测试。这些工作的延迟很高，因此不能像做单元测试时那样，写在setUp与tearDown 方法中。</p>
<p>unittest模块支持模块级别的测试用具初始化，以解决集成测试的准备与清理问题。这样的话，那些高成本的资源只在setUpModule中初始化一次就好，而不用在每个test方法运行之前都重复初始化一遍。待所有的test方法执行完，会在tearDownModule函数里清理这项资源，当然也只需要清理一次就行。下面我们就在包含TestCase子类的这个模块里定义setUpModule与tearDownModule函数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest <span class="keyword">import</span> TestCase, main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUpModule</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;* Module setup&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDownModule</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;* Module clean-up&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegrationTest</span>(<span class="params">TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Test setup&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Test clean-up&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_end_to_end1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Test 1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_end_to_end2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;* Test 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">* Module setup</span><br><span class="line">* Test setup</span><br><span class="line">* Test <span class="number">1</span></span><br><span class="line">* Test clean-up</span><br><span class="line">* Test setup</span><br><span class="line">* Test <span class="number">2</span></span><br><span class="line">* Test clean-up</span><br><span class="line">* Module clean-up</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">0.003</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="第78条-用Mock来模拟受测代码所依赖的复杂函数"><a href="#第78条-用Mock来模拟受测代码所依赖的复杂函数" class="headerlink" title="第78条  用Mock来模拟受测代码所依赖的复杂函数"></a>第78条  用Mock来模拟受测代码所依赖的复杂函数</h2><p>写测试的时候还有一个常见的问题，就是某些逻辑很难从开发环境里真实的执行，或者使用起来特别慢，这样的逻辑可以通过mock函数与Mock类来模拟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseConnectionError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_animals</span>(<span class="params">database, species</span>):</span></span><br><span class="line">    <span class="comment"># Query the Database</span></span><br><span class="line">    <span class="keyword">raise</span> DatabaseConnectionError(<span class="string">&#x27;Not connected&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mock = Mock(spec=get_animals)</span><br><span class="line">expected = [</span><br><span class="line">    (<span class="string">&#x27;Spot&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>)),</span><br><span class="line">    (<span class="string">&#x27;Fluffy&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">30</span>)),</span><br><span class="line">    (<span class="string">&#x27;Jojo&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">45</span>)),</span><br><span class="line">]</span><br><span class="line">mock.return_value = expected</span><br></pre></td></tr></table></figure>

<ul>
<li><p>unittest.mock模块中的Mock类能够模拟某个接口的行为，我们可以用它替换受测函数所要调用的接口，因为那些接口可能不太容易在测试的过程中配置。</p>
</li>
<li><p>如果用mock把受测代码所依赖的函数替换掉了，那么在测试的时候，不仅要验证受测代码的行为，而且还要验证它有没有正确地调用这些mock，这可以通过Mock.assert_called_once_with等一系列方法实现。</p>
</li>
<li><p>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</p>
</li>
</ul>
<h2 id="第79条-把受测代码所依赖的系统封装起来，以便于模拟和测试"><a href="#第79条-把受测代码所依赖的系统封装起来，以便于模拟和测试" class="headerlink" title="第79条  把受测代码所依赖的系统封装起来，以便于模拟和测试"></a>第79条  把受测代码所依赖的系统封装起来，以便于模拟和测试</h2><p>上一条（也就是第78条）讲了怎样用Python内置的unittest.mock模块测试需要依赖复杂系统（例如数据库）才能运作的代码。我们当时讲了两套方案，一个是通过Mock类实现，另一个是通过patch方法实现。可是，这两种方案都要求我们在测试的过程中重复编写很多例行代码，这会让初次阅读代码的人很难理解我们究竟要验证什么。</p>
<p>有一种办法可以改进代码，就是把受测函数所要使用的数据库接口封装起来，这样我们就不用像原来那样，专门把数据库连接（DatabaseConnection）当作参数传给受测函数了，而是可以将封装好的系统传过去。这种代码重构通常是很值得采取的，因为这样可以形成更好的抽象层,让我们能够更方便地创建mock逻辑，并用这些仿制的逻辑来编写测试用例（还有一种重构，参见第89条）。下面重新定义受测函数所用到的三个辅助函数，但是这次我们将这些函数放在一个叫作ZooDatabase 的类中，让它们成为该类的方法，而不像原来那样作为独立的函数出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooDatabase</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_animals</span>(<span class="params">self, species</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_food_period</span>(<span class="params">self, species</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feed_animal</span>(<span class="params">self, name, when</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_rounds</span>(<span class="params">database, species, *, utcnow=datetime.utcnow</span>):</span></span><br><span class="line">    now = utcnow()</span><br><span class="line">    feeding_timedelta = database.get_food_period(species)</span><br><span class="line">    animals = database.get_animals(species)</span><br><span class="line">    fed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, last_mealtime <span class="keyword">in</span> animals:</span><br><span class="line">        <span class="keyword">if</span> (now - last_mealtime) &gt;= feeding_timedelta:</span><br><span class="line">            database.feed_animal(name, now)</span><br><span class="line">            fed += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fed</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock</span><br><span class="line"></span><br><span class="line">database = Mock(spec=ZooDatabase)</span><br><span class="line">database.feed_animal()</span><br><span class="line">database.feed_animal.assert_any_call()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> call</span><br><span class="line"></span><br><span class="line">now_func = Mock(spec=datetime.utcnow)</span><br><span class="line">now_func.return_value = datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">database = Mock(spec=ZooDatabase)</span><br><span class="line">database.get_food_period.return_value = timedelta(hours=<span class="number">3</span>)</span><br><span class="line">database.get_animals.return_value = [</span><br><span class="line">    (<span class="string">&#x27;Spot&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">15</span>)),</span><br><span class="line">    (<span class="string">&#x27;Fluffy&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">30</span>)),</span><br><span class="line">    (<span class="string">&#x27;Jojo&#x27;</span>, datetime(<span class="number">2019</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">55</span>))</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">result = do_rounds(database, <span class="string">&#x27;Meerkat&#x27;</span>, utcnow=now_func)</span><br><span class="line"><span class="keyword">assert</span> result == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">database.get_food_period.assert_called_once_with(<span class="string">&#x27;Meerkat&#x27;</span>)</span><br><span class="line">database.get_animals.assert_called_once_with(<span class="string">&#x27;Meerkat&#x27;</span>)</span><br><span class="line">database.feed_animal.assert_has_calls(</span><br><span class="line">    [</span><br><span class="line">        call(<span class="string">&#x27;Spot&#x27;</span>, now_func.return_value),</span><br><span class="line">        call(<span class="string">&#x27;Fluffy&#x27;</span>, now_func.return_value),</span><br><span class="line">    ],</span><br><span class="line">    any_order=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在写单元测试的时候，如果总是要反复使用许多代码来注入模拟的逻辑，那么可以考虑把受测函数所要用到的逻辑封装到类中，因为封装之后更容易注入。</li>
<li>Python内置的unittest.mock模块里有个 Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的的属性。</li>
<li>如果想把程序完整地测一遍，那么可以重构代码，在原来直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</li>
</ul>
<h2 id="第80条-考虑用pdb做交互测试"><a href="#第80条-考虑用pdb做交互测试" class="headerlink" title="第80条  考虑用pdb做交互测试"></a>第80条  考虑用pdb做交互测试</h2><p>在编写程序的过程中总是会遇到bug。有时，可以通过print函数打印相关的信息，以追查导致程序出错的原因（参见第75条）；有时针对特定的情况编写测试用例也可以很明确地把程序所遇到的问题暴露出来（参见第<br>76条）。</p>
<p>但是，这些手段并不能发现所有的错误，有时我们得求助更强大的工具。Python内置的交互调试器（interactive debugger）就是这样一种工具，它可以检查程序状态打印局部变量的值，还可以每次只执行一条Python语句（也就是单步执行））。</p>
<p>在其他大部分编程语言中，如果要使用调试器，那么必须先在源文件中指定断点，令程序在执行到这一行时停下来。然而 Python不用这样，你可以直接在认为有问题的那行代码前加入一条指令，让程序暂停，并启动调试器，这是最简单的办法。采用这种办法来调试程序，与正常启动程序并没有什么区别。</p>
<p>用来触发调试器的指令是breakpoint函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rmse</span>(<span class="params">observed, ideal</span>):</span></span><br><span class="line">    total_err_2 = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> got, wanted <span class="keyword">in</span> <span class="built_in">zip</span>(observed, ideal):</span><br><span class="line">        err_2 = (got - wanted) ** <span class="number">2</span></span><br><span class="line">        <span class="built_in">breakpoint</span>()  <span class="comment"># Start the debugger here</span></span><br><span class="line">        total_err_2 += err_2</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mean_err = total_err_2 / count</span><br><span class="line">    rmse = math.sqrt(mean_err)</span><br><span class="line">    <span class="keyword">return</span> rmse</span><br><span class="line"></span><br><span class="line">result = compute_rmse(</span><br><span class="line">    [<span class="number">1.8</span>, <span class="number">1.7</span>, <span class="number">3.2</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">1.5</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>在（Pdb）提示符界面我们可以输入局部变量的名称（或执行p &lt;name&gt;命令）来查看变量的取值。也可以调用Python内置的locals函数以观察所有的局部变量，还可以引入模块，检查全局状态，构造新的对象，或运行内置的help命令，甚至还能修改正在运行的程序里的某些部分。总之，对调试工作有帮助的操作都可以在这里执行。</p>
<p>另外，调试器还提供了各种特殊命令，帮我们控制程序的执行方式，并探查其执行情况。在调试界面输入help，可以看到完整的命令列表。</p>
<p>通过下面这三条非常实用的命令，我们可以很方便地检查正在运行的这个程序：</p>
<ul>
<li>where：打印出当前的执行调用栈（execution call stack），可以据此判断程序当前执行到了哪个位置，以及程序是在调用了哪些函数后才触发breakpoint断点的。</li>
<li>up：把观察点沿着执行调用栈上移一层，回到当前函数调用者处，以观察位于当前断点之上的那些层面分别有什么样的局部变量。</li>
<li>down：把观察点沿着执行调用栈下移一层。</li>
</ul>
<p>检查完程序的运行状态后，可以通过下面这五条命令决定程序接下来应该如何执行：</p>
<ul>
<li>step：执行程序里的下一行代码，并在执行完毕后把控制权交还给调试器。如果下一行代码带有函数调用操作，那么调试器就会停在受调用的那个函数开头。</li>
<li>next ：执行当前函数的下一行代码，并在执行完毕后，返回交互调试界面。如果下一行代码带有函数调用操作，系统不会令调试器停在受调用的函数开头。</li>
<li>return：让程序一直运行到当前函数返回为止，然后把控制权交还给调试器。</li>
<li>continue ：让程序运行到下一个断点处（那个断点可以是通过breakpoint触发的，也可以是在调试界面里设置的）。</li>
<li>quit：退出调试界面，并且让接受调试的程序也随之终止。如果已经找到了问题，那么就可以用这个命令结束调试。如果发现寻找的方向不对，或者需要先去修改程序的代码，那么也应该运行这个命令以便重新调试。</li>
</ul>
<p>breakpoint函数可以出现在程序里的任何地方。</p>
<p>调试器还支持一项有用的功能，叫作事后调试（post-mortem debugging），当我们发现程序会抛出异常并崩溃后，想通过调试器看看它在抛出异常的那一刻，究竟是什么样子的。有时我们也不确定应该在哪里调用 breakpoint函数，在这种情况下，尤其需要这项功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rmse</span>(<span class="params">observed, ideal</span>):</span></span><br><span class="line">    total_err_2 = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> got, wanted <span class="keyword">in</span> <span class="built_in">zip</span>(observed, ideal):</span><br><span class="line">        err_2 = (got - wanted) ** <span class="number">2</span></span><br><span class="line">        total_err_2 += err_2</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mean_err = total_err_2 / count</span><br><span class="line">    rmse = math.sqrt(mean_err)</span><br><span class="line">    <span class="keyword">return</span> rmse</span><br><span class="line"></span><br><span class="line">result = compute_rmse(</span><br><span class="line">    [<span class="number">1.8</span>, <span class="number">1.7</span>, <span class="number">3.2</span>, <span class="number">7j</span>],  <span class="comment"># Bad input</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">1.5</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb -c continue &lt;program path&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第81条-用tracemalloc来掌握内存的使用与泄露情况"><a href="#第81条-用tracemalloc来掌握内存的使用与泄露情况" class="headerlink" title="第81条  用tracemalloc来掌握内存的使用与泄露情况"></a>第81条  用tracemalloc来掌握内存的使用与泄露情况</h2><p>在Python的默认实现方式（也就是CPython）中，内存管理是通过引用计数（referencecounting）执行的。如果指向某个对象的引用已经全部过期，那么受引用的对象就可以从内存中清除，从而给其他数据腾出空间。另外，CPython还内置了循环检测器（cycle detector），确保那些自我引用的对象也能够得到清除。</p>
<p>从理论上讲，这意味着Python开发者不用担心程序如何分配并释放内存的问题，因为Python系统本身以及CPython运行时环境会自动处理这些问题。但实际上，还是会有程序因为没有及时释放不再需要引用的数据而耗尽内存。想了解Python程序使用内存的情况，或找到泄漏内存的原因，是比较困难的。</p>
<p>第一种调试内存使用状况的办法，是用Python内置的gc模块把垃圾回收器目前知道的每个对象都列出来。虽然这样有点儿笨，但毕竟可以让我们迅速得知程序的内存使用状况。</p>
<p>下面先定义这样一个准备接受测试的模块，让它生成一些对象并加以引用，从而令这些对象能够占据一定空间。然后运行，再打印。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = os.urandom(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>():</span></span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        obj = MyObject()</span><br><span class="line">        values.append(obj)</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    deep_values = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        deep_values.append(get_data())</span><br><span class="line">    <span class="keyword">return</span> deep_values</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">found_objects = gc.get_objects()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Before:&#x27;</span>, <span class="built_in">len</span>(found_objects))</span><br><span class="line"></span><br><span class="line">hold_reference = run()</span><br><span class="line"></span><br><span class="line">found_objects = gc.get_objects()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After: &#x27;</span>, <span class="built_in">len</span>(found_objects))</span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> found_objects[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(obj)[:<span class="number">100</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Before: <span class="number">7750</span></span><br><span class="line">After:  <span class="number">17802</span></span><br><span class="line">&lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x000001E57D1D7B90</span>&gt;</span><br><span class="line">&lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x000001E57D1D7BD0</span>&gt;</span><br><span class="line">&lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x000001E57D1D7C10</span>&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>gc.get_objects函数的缺点在于，它并没有指出这些对象究竟要如何分配。在比较复杂的程序中，同一个类的对象可能是因为好几种不同的原因而为系统所分配的。知道对象的总数固然有意义，但更为重要的是找到分配这些对象的具体代码，这样才能查清内存泄漏的原因。</p>
<p>Python 3.4版本推出了一个新的内置模块，名为tracemalloc，它可以解决刚才讲的那个问题。tracemalloc能够追溯对象到分配它的位置，因此我们可以在执行受测模块之前与执行完毕之后，分别给内存使用情况做快照，并对比两份快照，以了解它们之间的区别。</p>
<p>下面我们就用这个方法把受测程序中分配内存最多的那三处找出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line">tracemalloc.start(<span class="number">10</span>)                      <span class="comment"># Set stack depth</span></span><br><span class="line">time1 = tracemalloc.take_snapshot()        <span class="comment"># Before snapshot</span></span><br><span class="line"></span><br><span class="line">x = run()                     <span class="comment"># Usage to debug</span></span><br><span class="line">time2 = tracemalloc.take_snapshot()        <span class="comment"># After snapshot</span></span><br><span class="line"></span><br><span class="line">stats = time2.compare_to(time1, <span class="string">&#x27;lineno&#x27;</span>)  <span class="comment"># Compare snapshots</span></span><br><span class="line"><span class="keyword">for</span> stat <span class="keyword">in</span> stats[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(stat)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">C:\XXX.py:<span class="number">5</span>: size=<span class="number">1299</span> KiB (+<span class="number">1299</span> KiB), count=<span class="number">10000</span> (+<span class="number">10000</span>), average=<span class="number">133</span> B</span><br><span class="line">C:\XXX.py:<span class="number">10</span>: size=<span class="number">785</span> KiB (+<span class="number">785</span> KiB), count=<span class="number">20000</span> (+<span class="number">20000</span>), average=<span class="number">40</span> B</span><br><span class="line">C:\XXX.py:<span class="number">11</span>: size=<span class="number">84.4</span> KiB (+<span class="number">84.4</span> KiB), count=<span class="number">100</span> (+<span class="number">100</span>), average=<span class="number">864</span> B</span><br></pre></td></tr></table></figure>

<p>tracemalloc还可以打印完整的栈追踪信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line">tracemalloc.start(<span class="number">10</span>)</span><br><span class="line">time1 = tracemalloc.take_snapshot()</span><br><span class="line"></span><br><span class="line">x = run()</span><br><span class="line">time2 = tracemalloc.take_snapshot()</span><br><span class="line"></span><br><span class="line">stats = time2.compare_to(time1, <span class="string">&#x27;traceback&#x27;</span>)</span><br><span class="line">top = stats[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Biggest offender is:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(top.traceback.<span class="built_in">format</span>()))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Biggest offender <span class="keyword">is</span>:</span><br><span class="line">  File <span class="string">&quot;C:\XXX.py&quot;</span>, line <span class="number">25</span></span><br><span class="line">    x = run()</span><br><span class="line">  File <span class="string">&quot;C:\XXX.py&quot;</span>, line <span class="number">17</span></span><br><span class="line">    deep_values.append(get_data())</span><br><span class="line">  File <span class="string">&quot;C:\XXX.py&quot;</span>, line <span class="number">10</span></span><br><span class="line">    obj = MyObject()</span><br><span class="line">  File <span class="string">&quot;C:\XXX.py&quot;</span>, line <span class="number">5</span></span><br><span class="line">    self.data = os.urandom(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h1 id="第十章-协作开发"><a href="#第十章-协作开发" class="headerlink" title="第十章  协作开发"></a>第十章  协作开发</h1><h2 id="第82条-学会寻找由其他Python开发者所构建的模块"><a href="#第82条-学会寻找由其他Python开发者所构建的模块" class="headerlink" title="第82条  学会寻找由其他Python开发者所构建的模块"></a>第82条  学会寻找由其他Python开发者所构建的模块</h2><p>Python有个集中存放模块的地方，叫Python Package Index（PyPI），网址<a target="_blank" rel="noopener" href="http://pypi.org,可以从中安装模块.可以用pip命令行工具安装软件包./">http://pypi.org，可以从中安装模块。可以用pip命令行工具安装软件包。</a></p>
<h2 id="第83条-用虚拟环境隔离项目，并重建依赖关系"><a href="#第83条-用虚拟环境隔离项目，并重建依赖关系" class="headerlink" title="第83条  用虚拟环境隔离项目，并重建依赖关系"></a>第83条  用虚拟环境隔离项目，并重建依赖关系</h2><p>pip会将新的安装包默认安装到全局路径之中，这会让每个涉及该模块的程序都受到影响。在间接的依赖关系中会出现问题。这个问题可以用虚拟环境解决：</p>
<h3 id="默认安装的内置工具venv。"><a href="#默认安装的内置工具venv。" class="headerlink" title="默认安装的内置工具venv。"></a>默认安装的内置工具venv。</h3><p>创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv &lt;env_name&gt;</span><br></pre></td></tr></table></figure>

<p>启用&#x2F;禁用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source bin/activate</span><br><span class="line">source bin/deactivate</span><br></pre></td></tr></table></figure>

<p>把当前环境所依赖的包保存到文件中，再重新安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip freeze &gt; requirements.txt</span><br><span class="line">python3 -m pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>网址：<a target="_blank" rel="noopener" href="https://www.anaconda.com/">https://www.anaconda.com</a></p>
<p>笔者更推荐使用Anaconda</p>
<h2 id="第84条-每一个函数、类与模块都要写docstring"><a href="#第84条-每一个函数、类与模块都要写docstring" class="headerlink" title="第84条  每一个函数、类与模块都要写docstring"></a>第84条  每一个函数、类与模块都要写docstring</h2><p>Python允许我们在程序运行过程中，直接访问这些文档：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrome</span>(<span class="params">word</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return True if the given word is a palindrome.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> word == word[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(palindrome.__doc__))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="string">&#x27;Return True if the given word is a palindrome.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>编写文档的优点：</p>
<ul>
<li>开发者能够在程序中访问文档信息，这会让交互式开发工作变得更加轻松。可以用内置的help函数查看与某个函数、类及模块相对应的文档。无论是基本的Python解释器界面（也就是默认的Python shell），还是IPython Notebook这样的高级工具，都可以相当方便地查询文档，这让我们能够愉快地研究算法、测试API并编写代码片段。</li>
<li>这些文档是按照标准的方式定义的，因此很容易就能转换成表现力更强的格式（例如HTML）。这也促使Python开发者推出Sphinx等优秀的文档生成工具，另外还有像Read the Docs这样由开发者社群所赞助的网站可以为开源的Python项目免费存放美观的文档。</li>
<li>Python文档不仅可以做得很漂亮，而且与其他普通的头等Python实体一样，也能够在程序里面正常地访问，这会让开发者更乐意编写这样的文档。许多Python开发者都坚信，文档是很重要的。有人认为，如果一段代码能称得上好代码，那么其中的文档肯定也写得不错。所以，很多优秀的开源Python项目里面，应该都有比较好的文档。</li>
</ul>
<h3 id="为模块编写文档"><a href="#为模块编写文档" class="headerlink" title="为模块编写文档"></a>为模块编写文档</h3><p>每个模块都要有顶级的docstring，即写在源文件开头的那个字符串。字符串的首尾都要带三重引号，这样的字符串的目的主要是介绍本模块与其中的内容。</p>
<p>在 docstring里面，第一行应是一个单句，描述本模块的用途。接下来应该另起一段，详解讲述使用这个模块的用户所要知道的一些事项。另外，凡是模块里面比较重要的类与函数，都应该在docstring 中予以强调，这样的话，查看这份文档的用户就可以从这些类及函数出发来熟悉模块。</p>
<p>下面举个例子，讲解如何为模块编写docstring。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Library for finding linguistic patterns in words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Testing how words relate to each other can be tricky sometimes!</span></span><br><span class="line"><span class="string">This module provides easy ways to determine when words you&#x27;ve</span></span><br><span class="line"><span class="string">found have special properties.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available functions:</span></span><br><span class="line"><span class="string">- palindrome: Determine if a word is a palindrome.</span></span><br><span class="line"><span class="string">- check_anagram: Determine if two words are anagrams.</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="为类编写文档"><a href="#为类编写文档" class="headerlink" title="为类编写文档"></a>为类编写文档</h3><p>每个类都应该有类级别的 docstring，这种文档的写法，与模块级别的docstring差不多。它的第一段，也需要用一句话来概述整个类的用途。后面的各段，可以详细讲解本类中的每一种操作。</p>
<p>类中比较重要的public属性与方法，同样应该在类级别的 docstring里面加以强调。另外还需要说明，如果想编写子类，子类应该怎样与受保护的属性（参见第42条）以及超类中的方法相交互。</p>
<p>下面演示类的 docstring应该如何编写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Represents a player of the game.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Subclasses may override the &#x27;tick&#x27; method to provide</span></span><br><span class="line"><span class="string">    custom animations for the player&#x27;s movement depending</span></span><br><span class="line"><span class="string">    on their power level, etc.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public attributes:</span></span><br><span class="line"><span class="string">    - power: Unused power-ups (float between 0 and 1).</span></span><br><span class="line"><span class="string">    - coins: Coins found during the level (integer).</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="为函数编写文档"><a href="#为函数编写文档" class="headerlink" title="为函数编写文档"></a>为函数编写文档</h3><p>每个 public函数与方法都应该有docstring。它的写法与模块和类的相同，第一段也是一个句子，描述这个函数是做什么的。接下来的那段应该描述函数的行为。然后，可以各用一段来描述函数的参数与返回值。另外，如果调用者在使用这个函数接口的时候，需要处理该函数所抛出的一些异常，那么这些异常也要解释（参见第20条）。</p>
<p>下面举例说明如何为函数编写 docstring。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span>(<span class="params">word, dictionary</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Find all anagrams for a word.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function only runs as fast as the test for</span></span><br><span class="line"><span class="string">    membership in the &#x27;dictionary&#x27; container.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        word: String of the target word.</span></span><br><span class="line"><span class="string">        dictionary: collections.abc.Container with all</span></span><br><span class="line"><span class="string">            strings that are known to be actual words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        List of anagrams that were found. Empty if</span></span><br><span class="line"><span class="string">        none were found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    permutations = itertools.permutations(word, <span class="built_in">len</span>(word))</span><br><span class="line">    possible = (<span class="string">&#x27;&#x27;</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> permutations)</span><br><span class="line">    found = &#123;word <span class="keyword">for</span> word <span class="keyword">in</span> possible <span class="keyword">if</span> word <span class="keyword">in</span> dictionary&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(found)</span><br></pre></td></tr></table></figure>

<p>写docstring的时候，需要注意下面几种特殊的情况：</p>
<ul>
<li>如果函数没有参数，而且返回的是个比较简单的值，那么就不用按照上面讲的那种格式分段书写了。直接用一句话来描述整个函数可能会更好。</li>
<li>如果函数没有返回值，那么最好是把描述返回值的那段完全省去，而不要专门写出返回None。</li>
<li>如果函数所抛出的异常也是接口的一部分（参见第20条），那么应该在docstring里面详细解释每一种异常的含义，并说明函数在什么场合会抛出这样的异常。</li>
<li>如果函数在正常使用的过程中，不会抛出异常，那么无须专门指出这一点。如果函数可以接受数量可变的位置参数（参见第22条或关键字参数（参见第23条），那么应该在解释参数的那一部分用*args与**kwargs来说明这两种参数的用途。</li>
<li>如果参数有默认值，那么文档里应该提到这些默认值（参见第24条）。</li>
<li>如果函数是个生成器（参见第30条），那么应该在docstring里面写明这个生成器在迭代过程中会产生什么样的值。</li>
<li>如果函数是异步协程（参见第60条），那么应该在docstring里面解释这个协程执行到何时会暂停。</li>
</ul>
<h3 id="用类型注解来简化docstring"><a href="#用类型注解来简化docstring" class="headerlink" title="用类型注解来简化docstring"></a>用类型注解来简化docstring</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Container, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_anagrams</span>(<span class="params">word: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                  dictionary: Container[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>类型信息最好只写在类型注解或docstring其中一个地方，防止修改时忘了改其中一个。</p>
<h2 id="第85条-用包来安排模块，以提供稳固的API"><a href="#第85条-用包来安排模块，以提供稳固的API" class="headerlink" title="第85条  用包来安排模块，以提供稳固的API"></a>第85条  用包来安排模块，以提供稳固的API</h2><p>大多数情况下，把名为__init__.py的空白文件放在某个目录中，即可令该目录成为一个包。</p>
<h3 id="用包划分名称空间"><a href="#用包划分名称空间" class="headerlink" title="用包划分名称空间"></a>用包划分名称空间</h3><p>包的一个用途是帮助把模块安排到不同的名称空间里，这样即使两个文件同名，也能够区分。</p>
<p>引入的函数或模块同名的话，应该加上as子句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> analysis.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> analysis_inspect</span><br><span class="line"><span class="keyword">from</span> frontend.utils <span class="keyword">import</span> inspect <span class="keyword">as</span> frontend_inspect</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> analysis.utils</span><br><span class="line"><span class="keyword">import</span> frontend.utils</span><br><span class="line"></span><br><span class="line">value = <span class="number">33</span></span><br><span class="line"><span class="keyword">if</span> (analysis.utils.inspect(value) ==</span><br><span class="line">    frontend.utils.inspect(value)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Inspection equal!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="通过包来构建稳固的API"><a href="#通过包来构建稳固的API" class="headerlink" title="通过包来构建稳固的API"></a>通过包来构建稳固的API</h3><p>要想API的功能稳定，必须隐藏软件包内部的代码结构，不要让外部的开发者依赖这套结构。</p>
<p>Python允许我们通过__all__这个特殊的属性，决定模块或包里面有哪些内容应该当做API公布到外界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># model.py</span></span><br><span class="line">__all__ = [<span class="string">&#x27;Projectile&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Projectile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, mass, velocity</span>):</span></span><br><span class="line">        self.mass = mass</span><br><span class="line">        self.velocity = velocity</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="keyword">from</span> . models <span class="keyword">import</span> Projectile</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;simulate_collision&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_dot_product</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_collision</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    after_a = Projectile(-a.mass, -a.velocity)</span><br><span class="line">    after_b = Projectile(-b.mass, -b.velocity)</span><br><span class="line">    <span class="keyword">return</span> after_a, after_b</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line">__all__ = []</span><br><span class="line"><span class="keyword">from</span> . models <span class="keyword">import</span> *</span><br><span class="line">__all__ += models.__all__</span><br><span class="line"><span class="keyword">from</span> . utils <span class="keyword">import</span> *</span><br><span class="line">__all__ += utils.__all__</span><br></pre></td></tr></table></figure>

<p><strong>尽量不要用import * 的形式！！</strong></p>
<h2 id="第86条-考虑用模块级别的代码配置不同的部署环境"><a href="#第86条-考虑用模块级别的代码配置不同的部署环境" class="headerlink" title="第86条  考虑用模块级别的代码配置不同的部署环境"></a>第86条  考虑用模块级别的代码配置不同的部署环境</h2><p>生产环境&#x2F;开发环境切换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dev_main.py</span></span><br><span class="line">TESTING = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> db_connection</span><br><span class="line"></span><br><span class="line">db = db_connection.Database()</span><br><span class="line"></span><br><span class="line"><span class="comment"># prod_main.py</span></span><br><span class="line">TESTING = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> db_connection</span><br><span class="line"></span><br><span class="line">db = db_connection.Database()</span><br><span class="line"></span><br><span class="line"><span class="comment"># db_connection.py</span></span><br><span class="line"><span class="keyword">import</span> __main__</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingDatabase</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealDatabase</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __main__.TESTING:</span><br><span class="line">    Database = TestingDatabase</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Database = RealDatabase</span><br></pre></td></tr></table></figure>

<h2 id="第87条-为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"><a href="#第87条-为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常" class="headerlink" title="第87条  为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常"></a>第87条  为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base-class for all exceptions raised by this module.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidDensityError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;There was a problem with a provided density value.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidVolumeError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;There was a problem with the provided weight value.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">determine_weight</span>(<span class="params">volume, density</span>):</span></span><br><span class="line">    <span class="keyword">if</span> density &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> InvalidDensityError(<span class="string">&#x27;Density must be positive&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> volume &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> InvalidVolumeError(<span class="string">&#x27;Volume must be positive&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> volume == <span class="number">0</span>:</span><br><span class="line">        density / volume</span><br></pre></td></tr></table></figure>

<p>有了这样的根异常，调用这个API的开发者就可以通过它把所有相关的错误全部捕获下来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_module</span>:</span></span><br><span class="line">    Error = Error</span><br><span class="line">    InvalidDensityError = InvalidDensityError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determine_weight</span>(<span class="params">volume, density</span>):</span></span><br><span class="line">        <span class="keyword">if</span> density &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> InvalidDensityError(<span class="string">&#x27;Density must be positive&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> volume &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> InvalidVolumeError(<span class="string">&#x27;Volume must be positive&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> volume == <span class="number">0</span>:</span><br><span class="line">            density / volume</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    weight = my_module.determine_weight(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> my_module.Error:</span><br><span class="line">    logging.exception(<span class="string">&#x27;Unexpected error&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>定义根异常有三大好处：</p>
<ul>
<li><p>让调用者能够注意自己在使用API时出现的疏忽。</p>
</li>
<li><p>有助于发现API本身的bug。写API时只抛出继承自根异常的错误。如果发生了其他错误，说明可能API实现里有bug。</p>
</li>
<li><p>让开发者以后能够平稳地更新API。</p>
</li>
</ul>
<p>这种思路还可以继续推广：在根异常下创建几个小的门类，让每个门类都有自己的根异常。</p>
<h2 id="第88条-用适当的方式打破循环依赖关系"><a href="#第88条-用适当的方式打破循环依赖关系" class="headerlink" title="第88条  用适当的方式打破循环依赖关系"></a>第88条  用适当的方式打破循环依赖关系</h2><p>与其他人合作的时候，难免会遇上两个模块相互依赖的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dialog.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, save_dir</span>):</span></span><br><span class="line">        self.save_dir = save_dir</span><br><span class="line"></span><br><span class="line">save_dialog = Dialog(app.prefs.get(<span class="string">&#x27;save_dir&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Showing the dialog!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">import</span> dialog</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prefs</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">prefs = Prefs()</span><br><span class="line">dialog.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br></pre></td></tr></table></figure>

<p>最好的解法是重构代码，把prefs数据结构放到依赖体系最底层。</p>
<p>除了这种解法以外，还有三个办法也可以解除循环依赖关系：</p>
<h3 id="调整import语句的位置"><a href="#调整import语句的位置" class="headerlink" title="调整import语句的位置"></a>调整import语句的位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prefs</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">prefs = Prefs()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dialog  <span class="comment"># Moved</span></span><br><span class="line">dialog.show()</span><br></pre></td></tr></table></figure>

<p>但这违背了PEP8，并且无法保证这份源文件里所有代码都能用这个导入模块。因此不推荐这种办法。</p>
<h3 id="把模块分成引入-配置-运行三个环节"><a href="#把模块分成引入-配置-运行三个环节" class="headerlink" title="把模块分成引入-配置-运行三个环节"></a>把模块分成引入-配置-运行三个环节</h3><p>尽量缩减引入时所要执行的操作，让模块只把函数、类与常量定义出来，而不真的去执行操作，这样的话，Python程序在引入本模块的时候，就不会由于操作其他模块而出错了。我们可以把本模块里面，需要用到其他模块的那种操作放在configure函数中，等到本模块彻底引入完毕后再去调用。configure函数会访问其他模块中的相关属性，以便将本模块的状态配置好。这个函数是在该模块与它所要使用的那个模块都已经彻底引人后才调用的（也就是说，这两个模块都把各自的第5步执行完了），因此，其中涉及的所有属性全都定义过了。</p>
<p>下面，我们就按照这个思路改写dialog模块，让它不要刚一上来就访问prefs对象，而是待configure函数被调用时，再去访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dialog.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">save_dialog = Dialog()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Showing the dialog!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span>():</span></span><br><span class="line">    save_dialog.save_dir = app.prefs.get(<span class="string">&#x27;save_dir&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">import</span> dialog</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prefs</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">prefs = Prefs()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configure</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">import</span> dialog</span><br><span class="line"></span><br><span class="line">app.configure()</span><br><span class="line">dialog.configure()</span><br><span class="line"></span><br><span class="line">dialog.show()</span><br></pre></td></tr></table></figure>

<h3 id="动态引入"><a href="#动态引入" class="headerlink" title="动态引入"></a>动态引入</h3><p>第三个办法比前两个都简单，也就是把import语句从模块级别下移到函数或方法里面，这样就可以解除循环依赖关系了。这种import语句并不会在程序启动并初始化本模块时执行，而是等到相关函数真正运行的时候才得以触发，因此又叫作动态引入（dynamic import）。</p>
<p>下面，我们就用动态引人的办法修改dialog模块。这次，它只会在dialog.show函数真正运行的时候去引入import模块，而不像原来那样，模块刚一初始化，就要引入app。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dialog.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using this instead will break things</span></span><br><span class="line"><span class="comment"># save_dialog = Dialog(app.prefs.get(&#x27;save_dir&#x27;))</span></span><br><span class="line">save_dialog = Dialog()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    <span class="keyword">import</span> app  <span class="comment"># Dynamic import</span></span><br><span class="line">    save_dialog.save_dir = app.prefs.get(<span class="string">&#x27;save_dir&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Showing the dialog!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样写，实际上与刚才那种先引入、再配置，然后运行的办法，是类似的。区别仅仅在于，这次不调整代码的结构，也不修改模块的定义与引人方式，只是把形成循环依赖的那条import语句，推迟到真正需要使用另外一个模块的那一刻。那时，自然可以确信本模块所依赖的那个模块肯定已经初始化过了（也就是说，那个模块的第5步肯<br>定已经执行完了）。</p>
<p>当然了，一般来说，还是应该尽量避免动态引入，因为import语句毕竟是有开销的，如果它出现在需要频繁执行的循环体里面，那么这种开销会更大。另外，由于动态引入会推迟代码的执行时机，有可能让你的程序在启动了很久之后，突然因为在动态引入其他模块的过程中发生SyntaxError等错误而崩溃（如何避免此类问题，请参见第76<br>条)。</p>
<h2 id="第89条-重构时考虑通过warnings提醒开发者API已经发生变化"><a href="#第89条-重构时考虑通过warnings提醒开发者API已经发生变化" class="headerlink" title="第89条  重构时考虑通过warnings提醒开发者API已经发生变化"></a>第89条  重构时考虑通过warnings提醒开发者API已经发生变化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">CONVERSIONS = &#123;</span><br><span class="line">    <span class="string">&#x27;mph&#x27;</span>: <span class="number">1.60934</span> / <span class="number">3600</span> * <span class="number">1000</span>,   <span class="comment"># m/s</span></span><br><span class="line">    <span class="string">&#x27;hours&#x27;</span>: <span class="number">3600</span>,                  <span class="comment"># seconds</span></span><br><span class="line">    <span class="string">&#x27;miles&#x27;</span>: <span class="number">1.60934</span> * <span class="number">1000</span>,        <span class="comment"># m</span></span><br><span class="line">    <span class="string">&#x27;meters&#x27;</span>: <span class="number">1</span>,                    <span class="comment"># m</span></span><br><span class="line">    <span class="string">&#x27;m/s&#x27;</span>: <span class="number">1</span>,                       <span class="comment"># m</span></span><br><span class="line">    <span class="string">&#x27;seconds&#x27;</span>: <span class="number">1</span>,                   <span class="comment"># s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">value, units</span>):</span></span><br><span class="line">    rate = CONVERSIONS[units]</span><br><span class="line">    <span class="keyword">return</span> rate * value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">localize</span>(<span class="params">value, units</span>):</span></span><br><span class="line">    rate = CONVERSIONS[units]</span><br><span class="line">    <span class="keyword">return</span> value / rate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_distance</span>(<span class="params">speed, duration, *,</span></span></span><br><span class="line"><span class="params"><span class="function">                   speed_units=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   time_units=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   distance_units=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> speed_units <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">&#x27;speed_units required&#x27;</span>, DeprecationWarning)</span><br><span class="line">        speed_units = <span class="string">&#x27;mph&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> time_units <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">&#x27;time_units required&#x27;</span>, DeprecationWarning)</span><br><span class="line">        time_units = <span class="string">&#x27;hours&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> distance_units <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">&#x27;distance_units required&#x27;</span>, DeprecationWarning)</span><br><span class="line">        distance_units = <span class="string">&#x27;miles&#x27;</span></span><br><span class="line"></span><br><span class="line">    norm_speed = convert(speed, speed_units)</span><br><span class="line">    norm_duration = convert(duration, time_units)</span><br><span class="line">    norm_distance = norm_speed * norm_duration</span><br><span class="line">    distance = localize(norm_distance, distance_units)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;distance&#125;</span> <span class="subst">&#123;distance_units&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">fake_stderr = io.StringIO()</span><br><span class="line"><span class="keyword">with</span> contextlib.redirect_stderr(fake_stderr):</span><br><span class="line">    print_distance(<span class="number">1000</span>, <span class="number">3</span>,</span><br><span class="line">                   speed_units=<span class="string">&#x27;meters&#x27;</span>,</span><br><span class="line">                   time_units=<span class="string">&#x27;seconds&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fake_stderr.getvalue())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">1.8641182099494205</span> miles</span><br><span class="line">C:\XXX.py:<span class="number">35</span>: DeprecationWarning: distance_units required</span><br><span class="line">  warnings.warn(</span><br></pre></td></tr></table></figure>

<p>warnings.warn函数提供了一个名为stacklevel的参数，让我们可以根据栈的深度指出真正触发这条警告的那个位置，而不是调用warnings.warn函数的字面位置。这项功能让我们可以把发出警告的这段逻辑封装成辅助函数，并通过这个辅助函数检查用户在调用print_distance时，有没有指定相关的参数，如果没有，就打印出调用print_distance的那行语句所在的位置。早前用来检查参数取值的那几个if结构，现在全都可以改由这样的辅助函数来实现。下面就定义辅助函数，如果用户没有明确给print_distance的某个参数传值，那么require函数会发出警告并且让该参数取默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">require</span>(<span class="params">name, value, default</span>):</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    warnings.warn(</span><br><span class="line">        <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> will be required soon, update your code&#x27;</span>,</span><br><span class="line">        DeprecationWarning,</span><br><span class="line">        stacklevel=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_distance</span>(<span class="params">speed, duration, *,</span></span></span><br><span class="line"><span class="params"><span class="function">                   speed_units=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   time_units=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   distance_units=<span class="literal">None</span></span>):</span></span><br><span class="line">    speed_units = require(<span class="string">&#x27;speed_units&#x27;</span>, speed_units, <span class="string">&#x27;mph&#x27;</span>)</span><br><span class="line">    time_units = require(<span class="string">&#x27;time_units&#x27;</span>, time_units, <span class="string">&#x27;hours&#x27;</span>)</span><br><span class="line">    distance_units = require(</span><br><span class="line">        <span class="string">&#x27;distance_units&#x27;</span>, distance_units, <span class="string">&#x27;miles&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    norm_speed = convert(speed, speed_units)</span><br><span class="line">    norm_duration = convert(duration, time_units)</span><br><span class="line">    norm_distance = norm_speed * norm_duration</span><br><span class="line">    distance = localize(norm_distance, distance_units)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;distance&#125;</span> <span class="subst">&#123;distance_units&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>设计新版API的时候，可以通过warnings模块把已经过时的用法通知到调用者，让他们看到消息后尽快改用新的写法，以防程序在我们彻底放弃旧版API之后崩溃。</li>
<li>在命令行界面执行Python解释器的时候，可以开启 -W error选项，从而将警告视为错误。这在执行自动测试的过程中特别有用，因为这样可以及时发现受测程序所依赖的 API是否已经推出了新的版本。</li>
<li>如果程序要部署到生产环境，那么可以通过logging模块将警告信息重定向到日志系统，把程序在运行过程中遇到的警告纳入现有的错误报告机制之中。</li>
<li>如果你设计的 API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</li>
</ul>
<h2 id="第90条-考虑通过typing做静态分析，以消除-bug"><a href="#第90条-考虑通过typing做静态分析，以消除-bug" class="headerlink" title="第90条  考虑通过typing做静态分析，以消除 bug"></a>第90条  考虑通过typing做静态分析，以消除 bug</h2><p>文档可以很好地帮助用户理解API的正确用法（参见第84条），然而只有文档可能还不够，有时我们还是会把API用错，导致程序出现bug。所以，最好能有一套机制来验证用者使用API的方式是否正确，如果我们把自己的API发布出去，那么这套机制还能帮助其他开发者检查他们的代码有没有恰当地使用这套API。<strong>许多编程语言通过编译期的类检查来实现这种验证，这确实能够消除某些bug。</strong></p>
<p>Python以前主要关注的是动态特性，所以没有提供编译期的类型安全机制。但是最近，Python开始引入一套特殊的写法，让我们可以通过内置的typing模块给变量、类中的字段、函数及方法添加类型信息。<strong>这些类型提示（type hint）信息可以实现渐进的类型判定机制（gradual typing），让我们在开发项目的过程中，把能够在编译期明确指定类型的地方逐渐确定下来。</strong></p>
<p>给Python程序的代码添加类型信息之后，我们就可以运行静态分析（static analysis）工具，分析这些代码里面是否存在极有可能出现bug的地方。Python内置的typing模块身并不实现类型检查功能，它只是一套可以公开使用的代码库，其中定义了相关的类型（也包括泛型类型），我们可以用这些类型来注解Python代码，并利用其他工具根据这些类型判断受注解的代码有没有正确地得到使用。</p>
<p>Python解释器有许多种不同的实现方案，例如CPython、PyPy等，与之类似，typing模块相搭配的Python静态分析工具，也有很多方案。笔者编写本书的时候，比较流行的是mypy、pytype、pyright 与pyre。本书中typing范例，笔者打算用mypy来验证，而且验证时会带上–strict标志，以便将该工具所能判断的各种问题全都显示出来。下面这行命令，可以用mypy给example.py文件里的代码做静态分析。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m mypy --strict example.py</span><br></pre></td></tr></table></figure>

<p>这些工具能够帮我们在运行程序之前，发现许多种常见的错误，除了把测试用例写好外（参见第76条），这样的工具会给代码多添加一层安全保障。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.value: <span class="built_in">int</span> = <span class="number">0</span>  <span class="comment"># Field / variable annotation</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, offset: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        value += offset      <span class="comment"># Oops: forgot &quot;self.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.value           <span class="comment"># Oops: forgot &quot;return&quot;</span></span><br><span class="line"></span><br><span class="line">counter = Counter()</span><br><span class="line">counter.add(<span class="number">5</span>)</span><br><span class="line">counter.add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">assert</span> counter.get() == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">python3 -m mypy --strict example.py</span><br><span class="line">.../example.py: error: Name <span class="string">&#x27;value&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">.../example.py: error: Missing <span class="keyword">return</span> statement</span><br></pre></td></tr></table></figure>

<p>可以利用typing模块给函数所涉及的泛型做注解，从而通过静态手段把程序运行时可能发生的错误提前探查出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, <span class="type">List</span>, TypeVar</span><br><span class="line"></span><br><span class="line">Value = TypeVar(<span class="string">&#x27;Value&#x27;</span>)</span><br><span class="line">Func = <span class="type">Callable</span>[[Value, Value], Value]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">func: Func[Value], values: <span class="type">List</span>[Value]</span>) -&gt; Value:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(values) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    result = values[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> next_value <span class="keyword">in</span> values[<span class="number">1</span>:]:</span><br><span class="line">        result = func(result, next_value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">Real = TypeVar(<span class="string">&#x27;Real&#x27;</span>, <span class="built_in">int</span>, <span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x: Real, y: Real</span>) -&gt; Real:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">inputs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4j</span>]  <span class="comment"># Oops: included a complex number</span></span><br><span class="line">result = combine(add, inputs)</span><br><span class="line"><span class="keyword">assert</span> result == <span class="number">10</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://sdupc.top">Chao Pang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://sdupc.top/2023/04/21/effective_python/">http://sdupc.top/2023/04/21/effective_python/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sdupc.top" target="_blank">Chao Pang的个人主页</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B9%A6%E7%B1%8D%E6%80%BB%E7%BB%93/">书籍总结</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/09/17/8fUOFNuDGX1lnhJ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/13/python_traps/" title="Python里的那些“坑”"><img class="cover" src="https://s2.loli.net/2023/11/21/Vs2j54JkSU6olAN.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python里的那些“坑”</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/17/spider/" title="爬虫逆向技术"><img class="cover" src="https://s2.loli.net/2023/10/20/vhEHoTkyeqpzu2M.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">爬虫逆向技术</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/11/29/nu4tpl8PIgFQBAr.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chao Pang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Pang-chao"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Pang-chao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:pc@sdupc.top" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://leetcode-cn.com/u/sdu-pc" target="_blank" title="Leetcode"><i class="fas fa-code"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一个热爱古诗词和历史的 ISTJ ，欢迎来到我的个人主页~有任何问题都可以与我邮件交流！邮箱：pc@sdupc.top</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%B9%E5%85%BBPythonic%E6%80%9D%E7%BB%B4"><span class="toc-number">1.</span> <span class="toc-text">第一章  培养Pythonic思维</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E6%9D%A1-%E6%9F%A5%E8%AF%A2%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E7%9A%84Python%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">第1条  查询自己使用的Python版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E6%9D%A1-%E9%81%B5%E5%BE%AAPEP8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97"><span class="toc-number">1.2.</span> <span class="toc-text">第2条  遵循PEP8风格指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E6%9D%A1-%E4%BA%86%E8%A7%A3bytes%E4%B8%8Estr%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">第3条  了解bytes与str区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E6%9D%A1-%E7%94%A8%E6%94%AF%E6%8C%81%E6%8F%92%E5%80%BC%E7%9A%84f-string%E5%8F%96%E4%BB%A3C%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8Estr-format%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">第4条  用支持插值的f-string取代C风格的格式字符串与str.format方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E6%9D%A1-%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E5%8F%96%E4%BB%A3%E5%A4%8D%E6%9D%82%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">第5条  用辅助函数取代复杂的表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E6%9D%A1-%E6%8A%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B4%E6%8E%A5%E6%8B%86%E5%88%86%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E9%87%8C%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%B8%93%E9%97%A8%E9%80%9A%E8%BF%87%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">1.6.</span> <span class="toc-text">第6条  把数据结构直接拆分到多个变量里，不要专门通过下标访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E6%9D%A1-%E5%B0%BD%E9%87%8F%E7%94%A8enumerate%E5%8F%96%E4%BB%A3range"><span class="toc-number">1.7.</span> <span class="toc-text">第7条  尽量用enumerate取代range</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E6%9D%A1-%E7%94%A8zip%E5%87%BD%E6%95%B0%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.8.</span> <span class="toc-text">第8条  用zip函数同时遍历两个生成器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E6%9D%A1-%E4%B8%8D%E8%A6%81%E5%9C%A8for%E4%B8%8Ewhile%E5%BE%AA%E7%8E%AF%E5%90%8E%E9%9D%A2%E5%86%99else%E5%9D%97"><span class="toc-number">1.9.</span> <span class="toc-text">第9条  不要在for与while循环后面写else块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E6%9D%A1-%E7%94%A8%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81"><span class="toc-number">1.10.</span> <span class="toc-text">第10条  用赋值表达式减少重复代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%88%97%E8%A1%A8%E4%B8%8E%E5%AD%97%E5%85%B8"><span class="toc-number">2.</span> <span class="toc-text">第二章  列表与字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E5%AF%B9%E5%BA%8F%E5%88%97%E5%81%9A%E5%88%87%E7%89%87"><span class="toc-number">2.1.</span> <span class="toc-text">第11条  学会对序列做切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E6%9D%A1-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%88%87%E7%89%87%E9%87%8C%E5%90%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E8%B5%B7%E6%AD%A2%E4%B8%8B%E6%A0%87%E5%92%8C%E6%AD%A5%E8%BF%9B"><span class="toc-number">2.2.</span> <span class="toc-text">第12条  不要在切片里同时指定起止下标和步进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E6%9D%A1-%E9%80%9A%E8%BF%87%E5%B8%A6%E6%98%9F%E5%8F%B7%E7%9A%84unpacking%E6%93%8D%E4%BD%9C%E6%9D%A5%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%E5%88%87%E7%89%87"><span class="toc-number">2.3.</span> <span class="toc-text">第13条  通过带星号的unpacking操作来捕获多个元素，不要用切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E6%9D%A1-%E7%94%A8sort%E6%96%B9%E6%B3%95%E7%9A%84key%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E6%8E%92%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="toc-number">2.4.</span> <span class="toc-text">第14条  用sort方法的key参数来表示复杂的排序逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E6%9D%A1-%E4%B8%8D%E8%A6%81%E8%BF%87%E5%88%86%E4%BE%9D%E8%B5%96%E7%BB%99%E5%AD%97%E5%85%B8%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE%E6%97%B6%E6%89%80%E7%94%A8%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">第15条  不要过分依赖给字典添加条目时所用的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E6%9D%A1-%E7%94%A8get%E5%A4%84%E7%90%86%E9%94%AE%E4%B8%8D%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8in%E4%B8%8EKeyError"><span class="toc-number">2.6.</span> <span class="toc-text">第16条  用get处理键不在字典中的情况，不要使用in与KeyError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E6%9D%A1-%E7%94%A8defaultdict%E5%A4%84%E7%90%86%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%A6%81%E7%94%A8setdefault"><span class="toc-number">2.7.</span> <span class="toc-text">第17条  用defaultdict处理内部状态中缺失的元素，而不要用setdefault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E5%88%A9%E7%94%A8-missing-%E6%9E%84%E9%80%A0%E4%BE%9D%E8%B5%96%E9%94%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.8.</span> <span class="toc-text">第18条  学会利用__missing__构造依赖键的默认值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">第三章  函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E6%9D%A1-%E4%B8%8D%E8%A6%81%E6%8A%8A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E5%80%BC%E6%8B%86%E5%88%86%E5%88%B0%E4%B8%89%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%AD"><span class="toc-number">3.1.</span> <span class="toc-text">第19条  不要把函数返回的多个数值拆分到三个以上的变量中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E6%9D%A1-%E9%81%87%E5%88%B0%E6%84%8F%E5%A4%96%E7%8A%B6%E5%86%B5%E6%97%B6%E5%BA%94%E8%AF%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%8D%E8%A6%81%E8%BF%94%E5%9B%9ENone"><span class="toc-number">3.2.</span> <span class="toc-text">第20条  遇到意外状况时应该抛出异常，不要返回None</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E6%9D%A1-%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8%E9%97%AD%E5%8C%85%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%A4%96%E5%9B%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">第21条  了解如何在闭包里面使用外围作用域中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC22%E6%9D%A1-%E7%94%A8%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%99%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">第22条  用数量可变的位置参数给函数设计清晰的参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC23%E6%9D%A1-%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8F%AF%E9%80%89%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.5.</span> <span class="toc-text">第23条  用关键字参数来表示可选的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC24%E6%9D%A1-%E7%94%A8None%E5%92%8Cdocstring%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E4%BC%9A%E5%8F%98%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">第24条  用None和docstring来描述默认值会变的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC25%E6%9D%A1-%E7%94%A8%E5%8F%AA%E8%83%BD%E4%BB%A5%E5%85%B3%E9%94%AE%E5%AD%97%E6%8C%87%E5%AE%9A%E5%92%8C%E5%8F%AA%E8%83%BD%E6%8C%89%E4%BD%8D%E7%BD%AE%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%99%B0%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">第25条  用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC26%E6%9D%A1-%E7%94%A8functools-wraps%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">第26条  用functools.wraps定义函数修饰器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A8%E5%AF%BC%E4%B8%8E%E7%94%9F%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">第四章  推导与生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC27%E6%9D%A1-%E7%94%A8%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%8F%96%E4%BB%A3map%E4%B8%8Efilter"><span class="toc-number">4.1.</span> <span class="toc-text">第27条  用列表推导取代map与filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC28%E6%9D%A1-%E6%8E%A7%E5%88%B6%E6%8E%A8%E5%AF%BC%E9%80%BB%E8%BE%91%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E8%A6%81%E8%B6%85%E8%BF%87%E4%B8%A4%E4%B8%AA"><span class="toc-number">4.2.</span> <span class="toc-text">第28条  控制推导逻辑的子表达式不要超过两个</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC29%E6%9D%A1-%E7%94%A8%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4%E6%8E%A8%E5%AF%BC%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">第29条  用赋值表达式消除推导中的重复代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC30%E6%9D%A1-%E4%B8%8D%E8%A6%81%E8%AE%A9%E5%87%BD%E6%95%B0%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%AE%A9%E5%AE%83%E9%80%90%E4%B8%AA%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8%E9%87%8C%E7%9A%84%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">第30条  不要让函数直接返回列表，应该让它逐个生成列表里的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC31%E6%9D%A1-%E8%B0%A8%E6%85%8E%E5%9C%B0%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0%E6%89%80%E6%94%B6%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">第31条  谨慎地迭代函数所收到的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC32%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E5%86%99%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BE%83%E5%A4%A7%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC"><span class="toc-number">4.6.</span> <span class="toc-text">第32条  考虑用生成器表达式改写数据量较大的列表推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC33%E6%9D%A1-%E9%80%9A%E8%BF%87yield-from%E6%8A%8A%E5%A4%9A%E4%B8%AA%E7%94%9F%E6%88%90%E5%99%A8%E8%BF%9E%E8%B5%B7%E6%9D%A5%E7%94%A8"><span class="toc-number">4.7.</span> <span class="toc-text">第33条  通过yield from把多个生成器连起来用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC34%E6%9D%A1-%E4%B8%8D%E8%A6%81%E7%94%A8send%E7%BB%99%E7%94%9F%E6%88%90%E5%99%A8%E6%B3%A8%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">4.8.</span> <span class="toc-text">第34条  不要用send给生成器注入数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC35%E6%9D%A1-%E4%B8%8D%E8%A6%81%E9%80%9A%E8%BF%87throw%E5%8F%98%E6%8D%A2%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.9.</span> <span class="toc-text">第35条  不要通过throw变换生成器的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC36%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8itertools%E6%8B%BC%E8%A3%85%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">4.10.</span> <span class="toc-text">第36条  考虑用itertools拼装迭代器与生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.10.1.</span> <span class="toc-text">连接多个迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chain"><span class="toc-number">4.10.1.1.</span> <span class="toc-text">chain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-number">4.10.1.2.</span> <span class="toc-text">repeat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cycle"><span class="toc-number">4.10.1.3.</span> <span class="toc-text">cycle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tee"><span class="toc-number">4.10.1.4.</span> <span class="toc-text">tee</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zip-longest"><span class="toc-number">4.10.1.5.</span> <span class="toc-text">zip_longest</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%BA%90%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">4.10.2.</span> <span class="toc-text">过滤源迭代器中的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#islice"><span class="toc-number">4.10.2.1.</span> <span class="toc-text">islice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#takewhile"><span class="toc-number">4.10.2.2.</span> <span class="toc-text">takewhile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dropwhile"><span class="toc-number">4.10.2.3.</span> <span class="toc-text">dropwhile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filterfalse"><span class="toc-number">4.10.2.4.</span> <span class="toc-text">filterfalse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%BA%90%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%90%88%E6%88%90%E6%96%B0%E5%85%83%E7%B4%A0"><span class="toc-number">4.10.3.</span> <span class="toc-text">用源迭代器中的元素合成新元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#accumulate"><span class="toc-number">4.10.3.1.</span> <span class="toc-text">accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#product"><span class="toc-number">4.10.3.2.</span> <span class="toc-text">product</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permutations"><span class="toc-number">4.10.3.3.</span> <span class="toc-text">permutations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#combinations"><span class="toc-number">4.10.3.4.</span> <span class="toc-text">combinations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#combinations-with-replacement"><span class="toc-number">4.10.3.5.</span> <span class="toc-text">combinations_with_replacement</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">第五章  类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC37%E6%9D%A1-%E7%94%A8%E7%BB%84%E5%90%88%E8%B5%B7%E6%9D%A5%E7%9A%84%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">第37条  用组合起来的类来实现多层结构，不要用嵌套的内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E9%87%8D%E6%9E%84%E4%B8%BA%E7%B1%BB%E4%BD%93%E7%B3%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">把多层嵌套的内置类型重构为类体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC38%E6%9D%A1-%E8%AE%A9%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%8F%97%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">第38条  让简单的接口接受函数，而不是类的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC39%E6%9D%A1-%E9%80%9A%E8%BF%87-classmethod%E5%A4%9A%E6%80%81%E6%9D%A5%E6%9E%84%E9%80%A0%E5%90%8C%E4%B8%80%E4%BD%93%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%90%84%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">第39条  通过@classmethod多态来构造同一体系中的各类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC40%E6%9D%A1-%E9%80%9A%E8%BF%87super%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B6%85%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">第40条  通过super初始化超类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC41%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8mix-in%E7%B1%BB%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%8F%AF%E7%BB%84%E5%90%88%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">5.5.</span> <span class="toc-text">第41条  考虑用mix-in类来表示可组合的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC42%E6%9D%A1-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%94%A8public%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA%E5%BA%94%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8private%E5%B1%9E%E6%80%A7%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.6.</span> <span class="toc-text">第42条  优先考虑用public属性表示应受保护的数据，不要用private属性表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC43%E6%9D%A1-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%BA%94%E8%AF%A5%E4%BB%8Ecollections-abc%E7%BB%A7%E6%89%BF"><span class="toc-number">5.7.</span> <span class="toc-text">第43条  自定义的容器类型应该从collections.abc继承</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%85%83%E7%B1%BB%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">第六章  元类与属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC44%E6%9D%A1-%E7%94%A8%E7%BA%AF%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BF%AE%E9%A5%B0%E5%99%A8%E5%8F%96%E4%BB%A3%E6%97%A7%E5%BC%8F%E7%9A%84setter%E4%B8%8Egetter%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">第44条  用纯属性与修饰器取代旧式的setter与getter方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC45%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8-property%E5%AE%9E%E7%8E%B0%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91%EF%BC%8C%E4%B8%8D%E8%A6%81%E6%80%A5%E7%9D%80%E9%87%8D%E6%9E%84%E5%8E%9F%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">第45条  考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC46%E6%9D%A1-%E7%94%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%9D%A5%E6%94%B9%E5%86%99%E9%9C%80%E8%A6%81%E5%A4%8D%E7%94%A8%E7%9A%84-property"><span class="toc-number">6.3.</span> <span class="toc-text">第46条  用描述符来改写需要复用的@property</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC47%E6%9D%A1-%E9%92%88%E5%AF%B9%E6%83%B0%E6%80%A7%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8-getattr-%E3%80%81-getattribute-%E5%8F%8A-setattr"><span class="toc-number">6.4.</span> <span class="toc-text">第47条  针对惰性属性使用__getattr__、__getattribute__及__setattr__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC48%E6%9D%A1-%E7%94%A8-init-subclass-%E9%AA%8C%E8%AF%81%E5%AD%90%E7%B1%BB%E5%86%99%E5%BE%97%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">6.5.</span> <span class="toc-text">第48条  用__init_subclass__验证子类写得是否正确</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC49%E6%9D%A1-%E7%94%A8-init-subclass-%E8%AE%B0%E5%BD%95%E7%8E%B0%E6%9C%89%E7%9A%84%E5%AD%90%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">第49条  用__init_subclass__记录现有的子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC50%E6%9D%A1-%E7%94%A8-set-name-%E7%BB%99%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%8A%A0%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.7.</span> <span class="toc-text">第50条  用__set_name__给类属性加注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC51%E6%9D%A1-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E9%80%9A%E8%BF%87%E7%B1%BB%E4%BF%AE%E9%A5%B0%E5%99%A8%E6%9D%A5%E6%8F%90%E4%BE%9B%E5%8F%AF%E7%BB%84%E5%90%88%E7%9A%84%E6%89%A9%E5%85%85%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB"><span class="toc-number">6.8.</span> <span class="toc-text">第51条  优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">7.</span> <span class="toc-text">第七章  并发与并行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC52%E6%9D%A1-%E7%94%A8subprocess%E7%AE%A1%E7%90%86%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">第52条  用subprocess管理子进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC53%E6%9D%A1-%E5%8F%AF%E4%BB%A5%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E9%98%BB%E5%A1%9E%E5%BC%8FI-O%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AE%83%E5%81%9A%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">7.2.</span> <span class="toc-text">第53条  可以用线程执行阻塞式I&#x2F;O，但不要用它做并行计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC54%E6%9D%A1-%E5%88%A9%E7%94%A8Lock%E9%98%B2%E6%AD%A2%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%89%E7%94%A8%E5%90%8C%E4%B8%80%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.</span> <span class="toc-text">第54条  利用Lock防止多个线程争用同一份数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC55%E6%9D%A1-%E7%94%A8Queue%E6%9D%A5%E5%8D%8F%E8%B0%83%E5%90%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%9B%E5%BA%A6"><span class="toc-number">7.4.</span> <span class="toc-text">第55条  用Queue来协调各线程之间的工作进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC56%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E5%88%A4%E6%96%AD%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%E5%BF%85%E9%A1%BB%E5%81%9A%E5%B9%B6%E5%8F%91"><span class="toc-number">7.5.</span> <span class="toc-text">第56条  学会判断什么场合必须做并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC57%E6%9D%A1-%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%AF%8F%E6%AC%A1fan-out%E6%97%B6%E9%83%BD%E6%96%B0%E5%BB%BA%E4%B8%80%E6%89%B9Thread%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.6.</span> <span class="toc-text">第57条  不要在每次fan-out时都新建一批Thread实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC58%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E6%AD%A3%E7%A1%AE%E5%9C%B0%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E4%BE%BF%E7%94%A8Queue%E5%81%9A%E5%B9%B6%E5%8F%91"><span class="toc-number">7.7.</span> <span class="toc-text">第58条  学会正确地重构代码，以便用Queue做并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC59%E6%9D%A1-%E5%A6%82%E6%9E%9C%E5%BF%85%E9%A1%BB%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%81%9A%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%82%A3%E5%B0%B1%E8%80%83%E8%99%91%E9%80%9A%E8%BF%87ThreadPoolExecutor%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.8.</span> <span class="toc-text">第59条  如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC60%E6%9D%A1-%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84I-O"><span class="toc-number">7.9.</span> <span class="toc-text">第60条  用协程实现高并发的I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC61%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E7%94%A8asyncio%E6%94%B9%E5%86%99%E9%82%A3%E4%BA%9B%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84I-O"><span class="toc-number">7.10.</span> <span class="toc-text">第61条  学会用asyncio改写那些通过线程实现的I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC62%E6%9D%A1-%E7%BB%93%E5%90%88%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B%EF%BC%8C%E5%B0%86%E4%BB%A3%E7%A0%81%E9%A1%BA%E5%88%A9%E8%BF%81%E7%A7%BB%E5%88%B0asyncio"><span class="toc-number">7.11.</span> <span class="toc-text">第62条  结合线程与协程，将代码顺利迁移到asyncio</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC63%E6%9D%A1-%E8%AE%A9asyncio%E7%9A%84%E6%97%B6%E9%97%B4%E5%BE%AA%E7%8E%AF%E4%BF%9D%E6%8C%81%E7%95%85%E9%80%9A%EF%BC%8C%E4%BB%A5%E4%BE%BF%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8F%90%E5%8D%87%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%93%8D%E5%BA%94%E8%83%BD%E5%8A%9B"><span class="toc-number">7.12.</span> <span class="toc-text">第63条  让asyncio的时间循环保持畅通，以便进一步提升程序的响应能力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC64%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8concurrent-futures%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">7.13.</span> <span class="toc-text">第64条  考虑用concurrent.futures实现真正的并行计算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A8%B3%E5%AE%9A%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">第八章  稳定与性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC65%E6%9D%A1-%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8try-except-else-finally%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">8.1.</span> <span class="toc-text">第65条  合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-finally%E5%BD%A2%E5%BC%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">try&#x2F;finally形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-except-else%E5%BD%A2%E5%BC%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">try&#x2F;except&#x2F;else形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84try-except-else-finally%E5%BD%A2%E5%BC%8F"><span class="toc-number">8.1.3.</span> <span class="toc-text">完整的try&#x2F;except&#x2F;else&#x2F;finally形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC66%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8contextlib%E4%B8%8Ewith%E8%AF%AD%E5%8F%A5%E6%9D%A5%E6%94%B9%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84try-finally%E4%BB%A3%E7%A0%81"><span class="toc-number">8.2.</span> <span class="toc-text">第66条  考虑用contextlib与with语句来改写可复用的try&#x2F;finally代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E7%9B%AE%E6%A0%87%E7%9A%84with%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">带目标的with语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC67%E6%9D%A1-%E7%94%A8datetime%E6%A8%A1%E5%9D%97%E5%A4%84%E7%90%86%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%EF%BC%8C%E4%B8%8D%E8%A6%81%E7%94%A8time%E6%A8%A1%E5%9D%97"><span class="toc-number">8.3.</span> <span class="toc-text">第67条  用datetime模块处理本地时间，不要用time模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#time%E6%A8%A1%E5%9D%97"><span class="toc-number">8.3.1.</span> <span class="toc-text">time模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#datatime%E6%A8%A1%E5%9D%97"><span class="toc-number">8.3.2.</span> <span class="toc-text">datatime模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC68%E6%9D%A1-%E7%94%A8copyreg%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E7%9A%84pickle%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.</span> <span class="toc-text">第68条  用copyreg实现可靠的pickle操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E6%96%B0%E5%B1%9E%E6%80%A7%E8%AE%BE%E5%AE%9A%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">8.4.1.</span> <span class="toc-text">给新属性设定默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%89%88%E6%9C%AC%E5%8F%B7%E6%A0%87%E6%B3%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9A%E4%B9%89"><span class="toc-number">8.4.2.</span> <span class="toc-text">用版本号标注同一个类的不同定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E7%B1%BB%E5%90%8D%E5%8F%98%E5%8C%96"><span class="toc-number">8.4.3.</span> <span class="toc-text">正确处理类名变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC69%E6%9D%A1-%E5%9C%A8%E9%9C%80%E8%A6%81%E5%87%86%E7%A1%AE%E8%AE%A1%E7%AE%97%E7%9A%84%E5%9C%BA%E5%90%88%EF%BC%8C%E7%94%A8decimal%E8%A1%A8%E7%A4%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E6%95%B0%E5%80%BC"><span class="toc-number">8.5.</span> <span class="toc-text">第69条  在需要准确计算的场合，用decimal表示相应的数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC70%E6%9D%A1-%E5%85%88%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E4%BC%98%E5%8C%96"><span class="toc-number">8.6.</span> <span class="toc-text">第70条  先分析性能，然后再优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC71%E6%9D%A1-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%94%A8deque%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%98%9F%E5%88%97"><span class="toc-number">8.7.</span> <span class="toc-text">第71条  优先考虑用deque实现生产者—消费者队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC72%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8bisect%E6%90%9C%E7%B4%A2%E5%B7%B2%E6%8E%92%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">8.8.</span> <span class="toc-text">第72条  考虑用bisect搜索已排序队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC73%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8heapq%E5%88%B6%E4%BD%9C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">8.9.</span> <span class="toc-text">第73条  学会使用heapq制作优先级队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC74%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8memoryview%E4%B8%8Ebytearray%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%9C%80%E6%8B%B7%E8%B4%9D%E7%9A%84bytes%E6%93%8D%E4%BD%9C"><span class="toc-number">8.10.</span> <span class="toc-text">第74条  考虑用memoryview与bytearray来实现无需拷贝的bytes操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">9.</span> <span class="toc-text">第九章  测试与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC75%E6%9D%A1-%E9%80%9A%E8%BF%87repr%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="toc-number">9.1.</span> <span class="toc-text">第75条  通过repr字符串输出调试信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC76%E6%9D%A1-%E5%9C%A8TestCase%E5%AD%90%E7%B1%BB%E9%87%8C%E9%AA%8C%E8%AF%81%E7%9B%B8%E5%85%B3%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.2.</span> <span class="toc-text">第76条  在TestCase子类里验证相关行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC77%E6%9D%A1-%E6%8A%8A%E6%B5%8B%E8%AF%95%E5%89%8D%E3%80%81%E5%90%8E%E7%9A%84%E5%87%86%E5%A4%87%E4%B8%8E%E6%B8%85%E7%90%86%E9%80%BB%E8%BE%91%E5%86%99%E5%9C%A8setUp%E3%80%81tearDown%E3%80%81setUp-Module%E4%B8%8EtearDown-Module%E4%B8%AD%EF%BC%8C%E4%BB%A5%E9%98%B2%E7%94%A8%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E5%B9%B2%E6%89%B0"><span class="toc-number">9.3.</span> <span class="toc-text">第77条  把测试前、后的准备与清理逻辑写在setUp、tearDown、setUp-Module与tearDown-Module中，以防用例之间相互干扰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC78%E6%9D%A1-%E7%94%A8Mock%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%8F%97%E6%B5%8B%E4%BB%A3%E7%A0%81%E6%89%80%E4%BE%9D%E8%B5%96%E7%9A%84%E5%A4%8D%E6%9D%82%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">第78条  用Mock来模拟受测代码所依赖的复杂函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC79%E6%9D%A1-%E6%8A%8A%E5%8F%97%E6%B5%8B%E4%BB%A3%E7%A0%81%E6%89%80%E4%BE%9D%E8%B5%96%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%B0%81%E8%A3%85%E8%B5%B7%E6%9D%A5%EF%BC%8C%E4%BB%A5%E4%BE%BF%E4%BA%8E%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">9.5.</span> <span class="toc-text">第79条  把受测代码所依赖的系统封装起来，以便于模拟和测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC80%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8pdb%E5%81%9A%E4%BA%A4%E4%BA%92%E6%B5%8B%E8%AF%95"><span class="toc-number">9.6.</span> <span class="toc-text">第80条  考虑用pdb做交互测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC81%E6%9D%A1-%E7%94%A8tracemalloc%E6%9D%A5%E6%8E%8C%E6%8F%A1%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5"><span class="toc-number">9.7.</span> <span class="toc-text">第81条  用tracemalloc来掌握内存的使用与泄露情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91"><span class="toc-number">10.</span> <span class="toc-text">第十章  协作开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC82%E6%9D%A1-%E5%AD%A6%E4%BC%9A%E5%AF%BB%E6%89%BE%E7%94%B1%E5%85%B6%E4%BB%96Python%E5%BC%80%E5%8F%91%E8%80%85%E6%89%80%E6%9E%84%E5%BB%BA%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">10.1.</span> <span class="toc-text">第82条  学会寻找由其他Python开发者所构建的模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC83%E6%9D%A1-%E7%94%A8%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%B9%B6%E9%87%8D%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">10.2.</span> <span class="toc-text">第83条  用虚拟环境隔离项目，并重建依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E7%9A%84%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7venv%E3%80%82"><span class="toc-number">10.2.1.</span> <span class="toc-text">默认安装的内置工具venv。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anaconda"><span class="toc-number">10.2.2.</span> <span class="toc-text">Anaconda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC84%E6%9D%A1-%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E4%B8%8E%E6%A8%A1%E5%9D%97%E9%83%BD%E8%A6%81%E5%86%99docstring"><span class="toc-number">10.3.</span> <span class="toc-text">第84条  每一个函数、类与模块都要写docstring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3"><span class="toc-number">10.3.1.</span> <span class="toc-text">为模块编写文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E7%B1%BB%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3"><span class="toc-number">10.3.2.</span> <span class="toc-text">为类编写文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%96%87%E6%A1%A3"><span class="toc-number">10.3.3.</span> <span class="toc-text">为函数编写文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E6%9D%A5%E7%AE%80%E5%8C%96docstring"><span class="toc-number">10.3.4.</span> <span class="toc-text">用类型注解来简化docstring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC85%E6%9D%A1-%E7%94%A8%E5%8C%85%E6%9D%A5%E5%AE%89%E6%8E%92%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BB%A5%E6%8F%90%E4%BE%9B%E7%A8%B3%E5%9B%BA%E7%9A%84API"><span class="toc-number">10.4.</span> <span class="toc-text">第85条  用包来安排模块，以提供稳固的API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%8C%85%E5%88%92%E5%88%86%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">10.4.1.</span> <span class="toc-text">用包划分名称空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8C%85%E6%9D%A5%E6%9E%84%E5%BB%BA%E7%A8%B3%E5%9B%BA%E7%9A%84API"><span class="toc-number">10.4.2.</span> <span class="toc-text">通过包来构建稳固的API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC86%E6%9D%A1-%E8%80%83%E8%99%91%E7%94%A8%E6%A8%A1%E5%9D%97%E7%BA%A7%E5%88%AB%E7%9A%84%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83"><span class="toc-number">10.5.</span> <span class="toc-text">第86条  考虑用模块级别的代码配置不同的部署环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC87%E6%9D%A1-%E4%B8%BA%E8%87%AA%E7%BC%96%E7%9A%84%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E6%A0%B9%E5%BC%82%E5%B8%B8%EF%BC%8C%E8%AE%A9%E8%B0%83%E7%94%A8%E8%80%85%E8%83%BD%E5%A4%9F%E4%B8%93%E9%97%A8%E5%A4%84%E7%90%86%E4%B8%8E%E6%AD%A4API%E6%9C%89%E5%85%B3%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">10.6.</span> <span class="toc-text">第87条  为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC88%E6%9D%A1-%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%93%E7%A0%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">10.7.</span> <span class="toc-text">第88条  用适当的方式打破循环依赖关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4import%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.7.1.</span> <span class="toc-text">调整import语句的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%A8%A1%E5%9D%97%E5%88%86%E6%88%90%E5%BC%95%E5%85%A5-%E9%85%8D%E7%BD%AE-%E8%BF%90%E8%A1%8C%E4%B8%89%E4%B8%AA%E7%8E%AF%E8%8A%82"><span class="toc-number">10.7.2.</span> <span class="toc-text">把模块分成引入-配置-运行三个环节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5"><span class="toc-number">10.7.3.</span> <span class="toc-text">动态引入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC89%E6%9D%A1-%E9%87%8D%E6%9E%84%E6%97%B6%E8%80%83%E8%99%91%E9%80%9A%E8%BF%87warnings%E6%8F%90%E9%86%92%E5%BC%80%E5%8F%91%E8%80%85API%E5%B7%B2%E7%BB%8F%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-number">10.8.</span> <span class="toc-text">第89条  重构时考虑通过warnings提醒开发者API已经发生变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC90%E6%9D%A1-%E8%80%83%E8%99%91%E9%80%9A%E8%BF%87typing%E5%81%9A%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%EF%BC%8C%E4%BB%A5%E6%B6%88%E9%99%A4-bug"><span class="toc-number">10.9.</span> <span class="toc-text">第90条  考虑通过typing做静态分析，以消除 bug</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/06/dps/" title="数字信号处理"><img src="https://s2.loli.net/2024/07/06/KlhjmBI9UvkFCAx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数字信号处理"/></a><div class="content"><a class="title" href="/2024/07/06/dps/" title="数字信号处理">数字信号处理</a><time datetime="2024-07-06T07:17:56.000Z" title="发表于 2024-07-06 15:17:56">2024-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/21/dockerfile/" title="Dockerfile入门与实践"><img src="https://s2.loli.net/2024/07/28/fLYDzOKwiHcB9jR.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dockerfile入门与实践"/></a><div class="content"><a class="title" href="/2024/06/21/dockerfile/" title="Dockerfile入门与实践">Dockerfile入门与实践</a><time datetime="2024-06-21T04:39:17.000Z" title="发表于 2024-06-21 12:39:17">2024-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/14/docker/" title="Docker"><img src="https://s2.loli.net/2024/07/28/ZfVE1yXw3eO4tI5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2024/05/14/docker/" title="Docker">Docker</a><time datetime="2024-05-14T08:35:28.000Z" title="发表于 2024-05-14 16:35:28">2024-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/28/software_design/" title="现代软件开发中的模式"><img src="https://s2.loli.net/2024/03/28/C79cXYjarenqxOo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="现代软件开发中的模式"/></a><div class="content"><a class="title" href="/2024/03/28/software_design/" title="现代软件开发中的模式">现代软件开发中的模式</a><time datetime="2024-03-28T14:34:28.000Z" title="发表于 2024-03-28 22:34:28">2024-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/16/stream_output/" title="ChatGPT的流式输出"><img src="https://s2.loli.net/2024/03/19/uLRs8M3VjJtXbZk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ChatGPT的流式输出"/></a><div class="content"><a class="title" href="/2024/03/16/stream_output/" title="ChatGPT的流式输出">ChatGPT的流式输出</a><time datetime="2024-03-16T06:29:48.000Z" title="发表于 2024-03-16 14:29:48">2024-03-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Chao Pang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>